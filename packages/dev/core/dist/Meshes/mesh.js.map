{"version":3,"file":"mesh.js","sourceRoot":"","sources":["../../src/Meshes/mesh.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Tools, AsyncLoop } from \"../Misc/tools\";\r\nimport type { IAnimatable } from \"../Animations/animatable.interface\";\r\nimport { DeepCopier } from \"../Misc/deepCopier\";\r\nimport { Tags } from \"../Misc/tags\";\r\nimport type { Coroutine } from \"../Misc/coroutine\";\r\nimport { runCoroutineSync, runCoroutineAsync, createYieldingScheduler } from \"../Misc/coroutine\";\r\nimport type { Nullable, FloatArray, IndicesArray } from \"../types\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Quaternion, Matrix, Vector3, Vector2 } from \"../Maths/math.vector\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport { Node } from \"../node\";\r\nimport { VertexBuffer, Buffer } from \"../Buffers/buffer\";\r\nimport type { IGetSetVerticesData } from \"./mesh.vertexData\";\r\nimport { VertexData } from \"./mesh.vertexData\";\r\n\r\nimport { Geometry } from \"./geometry\";\r\nimport { AbstractMesh } from \"./abstractMesh\";\r\nimport { SubMesh } from \"./subMesh\";\r\nimport type { BoundingSphere } from \"../Culling/boundingSphere\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { MultiMaterial } from \"../Materials/multiMaterial\";\r\nimport { SceneLoaderFlags } from \"../Loading/sceneLoaderFlags\";\r\nimport type { Skeleton } from \"../Bones/skeleton\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { SerializationHelper } from \"../Misc/decorators\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { GetClass, RegisterClass } from \"../Misc/typeStore\";\r\nimport { _WarnImport } from \"../Misc/devTools\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport { MeshLODLevel } from \"./meshLODLevel\";\r\nimport type { Path3D } from \"../Maths/math.path\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\nimport type { TransformNode } from \"./transformNode\";\r\nimport type { DrawWrapper } from \"../Materials/drawWrapper\";\r\n\r\ndeclare type GoldbergMesh = import(\"./goldbergMesh\").GoldbergMesh;\r\ndeclare type InstancedMesh = import(\"./instancedMesh\").InstancedMesh;\r\ndeclare type IPhysicsEnabledObject = import(\"../Physics/physicsImpostor\").IPhysicsEnabledObject;\r\ndeclare type PhysicsImpostor = import(\"../Physics/physicsImpostor\").PhysicsImpostor;\r\n\r\n/**\r\n * @hidden\r\n **/\r\nexport class _CreationDataStorage {\r\n    public closePath?: boolean;\r\n    public closeArray?: boolean;\r\n    public idx: number[];\r\n    public dashSize: number;\r\n    public gapSize: number;\r\n    public path3D: Path3D;\r\n    public pathArray: Vector3[][];\r\n    public arc: number;\r\n    public radius: number;\r\n    public cap: number;\r\n    public tessellation: number;\r\n}\r\n\r\n/**\r\n * @hidden\r\n **/\r\nclass _InstanceDataStorage {\r\n    public visibleInstances: any = {};\r\n    public batchCache = new _InstancesBatch();\r\n    public batchCacheReplacementModeInFrozenMode = new _InstancesBatch();\r\n    public instancesBufferSize = 32 * 16 * 4; // let's start with a maximum of 32 instances\r\n    public instancesBuffer: Nullable<Buffer>;\r\n    public instancesPreviousBuffer: Nullable<Buffer>;\r\n    public instancesData: Float32Array;\r\n    public instancesPreviousData: Float32Array;\r\n    public overridenInstanceCount: number;\r\n    public isFrozen: boolean;\r\n    public previousBatch: Nullable<_InstancesBatch>;\r\n    public hardwareInstancedRendering: boolean;\r\n    public sideOrientation: number;\r\n    public manualUpdate: boolean;\r\n    public previousManualUpdate: boolean;\r\n    public previousRenderId: number;\r\n    public masterMeshPreviousWorldMatrix: Nullable<Matrix>;\r\n}\r\n\r\n/**\r\n * @hidden\r\n **/\r\nexport class _InstancesBatch {\r\n    public mustReturn = false;\r\n    public visibleInstances = new Array<Nullable<Array<InstancedMesh>>>();\r\n    public renderSelf = new Array<boolean>();\r\n    public hardwareInstancedRendering = new Array<boolean>();\r\n}\r\n\r\n/**\r\n * @hidden\r\n **/\r\nclass _ThinInstanceDataStorage {\r\n    public instancesCount: number = 0;\r\n    public matrixBuffer: Nullable<Buffer> = null;\r\n    public previousMatrixBuffer: Nullable<Buffer> = null;\r\n    public matrixBufferSize = 32 * 16; // let's start with a maximum of 32 thin instances\r\n    public matrixData: Nullable<Float32Array> = null;\r\n    public previousMatrixData: Nullable<Float32Array>;\r\n    public boundingVectors: Array<Vector3> = [];\r\n    public worldMatrices: Nullable<Matrix[]> = null;\r\n    public masterMeshPreviousWorldMatrix: Nullable<Matrix>;\r\n}\r\n\r\n/**\r\n * @hidden\r\n **/\r\nclass _InternalMeshDataInfo {\r\n    // Events\r\n    public _onBeforeRenderObservable: Nullable<Observable<Mesh>>;\r\n    public _onBeforeBindObservable: Nullable<Observable<Mesh>>;\r\n    public _onAfterRenderObservable: Nullable<Observable<Mesh>>;\r\n    public _onBeforeDrawObservable: Nullable<Observable<Mesh>>;\r\n    public _onBetweenPassObservable: Nullable<Observable<SubMesh>>;\r\n\r\n    public _areNormalsFrozen: boolean = false; // Will be used by ribbons mainly\r\n    public _sourcePositions: Nullable<Float32Array>; // Will be used to save original positions when using software skinning\r\n    public _sourceNormals: Nullable<Float32Array>; // Will be used to save original normals when using software skinning\r\n\r\n    // Will be used to save a source mesh reference, If any\r\n    public _source: Nullable<Mesh> = null;\r\n    // Will be used to for fast cloned mesh lookup\r\n    public meshMap: Nullable<{ [id: string]: Mesh | undefined }> = null;\r\n\r\n    public _preActivateId: number = -1;\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public _LODLevels = new Array<MeshLODLevel>();\r\n    /** Alternative definition of LOD level, using screen coverage instead of distance */\r\n    public _useLODScreenCoverage: boolean = false;\r\n    public _checkReadinessObserver: Nullable<Observer<Scene>>;\r\n\r\n    public _onMeshReadyObserverAdded: (observer: Observer<Mesh>) => void;\r\n\r\n    public _effectiveMaterial: Nullable<Material> = null;\r\n\r\n    public _forcedInstanceCount: number = 0;\r\n}\r\n\r\n/**\r\n * Class used to represent renderable models\r\n */\r\nexport class Mesh extends AbstractMesh implements IGetSetVerticesData {\r\n    // Consts\r\n\r\n    /**\r\n     * Mesh side orientation : usually the external or front surface\r\n     */\r\n    public static readonly FRONTSIDE = VertexData.FRONTSIDE;\r\n\r\n    /**\r\n     * Mesh side orientation : usually the internal or back surface\r\n     */\r\n    public static readonly BACKSIDE = VertexData.BACKSIDE;\r\n    /**\r\n     * Mesh side orientation : both internal and external or front and back surfaces\r\n     */\r\n    public static readonly DOUBLESIDE = VertexData.DOUBLESIDE;\r\n    /**\r\n     * Mesh side orientation : by default, `FRONTSIDE`\r\n     */\r\n    public static readonly DEFAULTSIDE = VertexData.DEFAULTSIDE;\r\n    /**\r\n     * Mesh cap setting : no cap\r\n     */\r\n    public static readonly NO_CAP = 0;\r\n    /**\r\n     * Mesh cap setting : one cap at the beginning of the mesh\r\n     */\r\n    public static readonly CAP_START = 1;\r\n    /**\r\n     * Mesh cap setting : one cap at the end of the mesh\r\n     */\r\n    public static readonly CAP_END = 2;\r\n    /**\r\n     * Mesh cap setting : two caps, one at the beginning  and one at the end of the mesh\r\n     */\r\n    public static readonly CAP_ALL = 3;\r\n    /**\r\n     * Mesh pattern setting : no flip or rotate\r\n     */\r\n    public static readonly NO_FLIP = 0;\r\n    /**\r\n     * Mesh pattern setting : flip (reflect in y axis) alternate tiles on each row or column\r\n     */\r\n    public static readonly FLIP_TILE = 1;\r\n    /**\r\n     * Mesh pattern setting : rotate (180degs) alternate tiles on each row or column\r\n     */\r\n    public static readonly ROTATE_TILE = 2;\r\n    /**\r\n     * Mesh pattern setting : flip (reflect in y axis) all tiles on alternate rows\r\n     */\r\n    public static readonly FLIP_ROW = 3;\r\n    /**\r\n     * Mesh pattern setting : rotate (180degs) all tiles on alternate rows\r\n     */\r\n    public static readonly ROTATE_ROW = 4;\r\n    /**\r\n     * Mesh pattern setting : flip and rotate alternate tiles on each row or column\r\n     */\r\n    public static readonly FLIP_N_ROTATE_TILE = 5;\r\n    /**\r\n     * Mesh pattern setting : rotate pattern and rotate\r\n     */\r\n    public static readonly FLIP_N_ROTATE_ROW = 6;\r\n    /**\r\n     * Mesh tile positioning : part tiles same on left/right or top/bottom\r\n     */\r\n    public static readonly CENTER = 0;\r\n    /**\r\n     * Mesh tile positioning : part tiles on left\r\n     */\r\n    public static readonly LEFT = 1;\r\n    /**\r\n     * Mesh tile positioning : part tiles on right\r\n     */\r\n    public static readonly RIGHT = 2;\r\n    /**\r\n     * Mesh tile positioning : part tiles on top\r\n     */\r\n    public static readonly TOP = 3;\r\n    /**\r\n     * Mesh tile positioning : part tiles on bottom\r\n     */\r\n    public static readonly BOTTOM = 4;\r\n\r\n    /**\r\n     * Indicates that the instanced meshes should be sorted from back to front before rendering if their material is transparent\r\n     */\r\n    public static INSTANCEDMESH_SORT_TRANSPARENT = false;\r\n\r\n    /**\r\n     * Gets the default side orientation.\r\n     * @param orientation the orientation to value to attempt to get\r\n     * @returns the default orientation\r\n     * @hidden\r\n     */\r\n    public static _GetDefaultSideOrientation(orientation?: number): number {\r\n        return orientation || Mesh.FRONTSIDE; // works as Mesh.FRONTSIDE is 0\r\n    }\r\n\r\n    // Internal data\r\n    private _internalMeshDataInfo = new _InternalMeshDataInfo();\r\n\r\n    /**\r\n     * Determines if the LOD levels are intended to be calculated using screen coverage (surface area ratio) instead of distance\r\n     */\r\n    public get useLODScreenCoverage() {\r\n        return this._internalMeshDataInfo._useLODScreenCoverage;\r\n    }\r\n\r\n    public set useLODScreenCoverage(value: boolean) {\r\n        this._internalMeshDataInfo._useLODScreenCoverage = value;\r\n    }\r\n\r\n    /**\r\n     * Will notify when the mesh is completely ready, including materials.\r\n     * Observers added to this observable will be removed once triggered\r\n     */\r\n    public onMeshReadyObservable: Observable<Mesh>;\r\n\r\n    public get computeBonesUsingShaders(): boolean {\r\n        return this._internalAbstractMeshDataInfo._computeBonesUsingShaders;\r\n    }\r\n    public set computeBonesUsingShaders(value: boolean) {\r\n        if (this._internalAbstractMeshDataInfo._computeBonesUsingShaders === value) {\r\n            return;\r\n        }\r\n\r\n        if (value && this._internalMeshDataInfo._sourcePositions) {\r\n            // switch from software to GPU computation: we need to reset the vertex and normal buffers that have been updated by the software process\r\n            this.setVerticesData(VertexBuffer.PositionKind, this._internalMeshDataInfo._sourcePositions, true);\r\n            if (this._internalMeshDataInfo._sourceNormals) {\r\n                this.setVerticesData(VertexBuffer.NormalKind, this._internalMeshDataInfo._sourceNormals, true);\r\n            }\r\n\r\n            this._internalMeshDataInfo._sourcePositions = null;\r\n            this._internalMeshDataInfo._sourceNormals = null;\r\n        }\r\n\r\n        this._internalAbstractMeshDataInfo._computeBonesUsingShaders = value;\r\n        this._markSubMeshesAsAttributesDirty();\r\n    }\r\n\r\n    /**\r\n     * An event triggered before rendering the mesh\r\n     */\r\n    public get onBeforeRenderObservable(): Observable<Mesh> {\r\n        if (!this._internalMeshDataInfo._onBeforeRenderObservable) {\r\n            this._internalMeshDataInfo._onBeforeRenderObservable = new Observable<Mesh>();\r\n        }\r\n\r\n        return this._internalMeshDataInfo._onBeforeRenderObservable;\r\n    }\r\n\r\n    /**\r\n     * An event triggered before binding the mesh\r\n     */\r\n    public get onBeforeBindObservable(): Observable<Mesh> {\r\n        if (!this._internalMeshDataInfo._onBeforeBindObservable) {\r\n            this._internalMeshDataInfo._onBeforeBindObservable = new Observable<Mesh>();\r\n        }\r\n\r\n        return this._internalMeshDataInfo._onBeforeBindObservable;\r\n    }\r\n\r\n    /**\r\n     * An event triggered after rendering the mesh\r\n     */\r\n    public get onAfterRenderObservable(): Observable<Mesh> {\r\n        if (!this._internalMeshDataInfo._onAfterRenderObservable) {\r\n            this._internalMeshDataInfo._onAfterRenderObservable = new Observable<Mesh>();\r\n        }\r\n\r\n        return this._internalMeshDataInfo._onAfterRenderObservable;\r\n    }\r\n\r\n    /**\r\n     * An event triggeredbetween rendering pass when using separateCullingPass = true\r\n     */\r\n    public get onBetweenPassObservable(): Observable<SubMesh> {\r\n        if (!this._internalMeshDataInfo._onBetweenPassObservable) {\r\n            this._internalMeshDataInfo._onBetweenPassObservable = new Observable<SubMesh>();\r\n        }\r\n\r\n        return this._internalMeshDataInfo._onBetweenPassObservable;\r\n    }\r\n\r\n    /**\r\n     * An event triggered before drawing the mesh\r\n     */\r\n    public get onBeforeDrawObservable(): Observable<Mesh> {\r\n        if (!this._internalMeshDataInfo._onBeforeDrawObservable) {\r\n            this._internalMeshDataInfo._onBeforeDrawObservable = new Observable<Mesh>();\r\n        }\r\n\r\n        return this._internalMeshDataInfo._onBeforeDrawObservable;\r\n    }\r\n\r\n    private _onBeforeDrawObserver: Nullable<Observer<Mesh>>;\r\n\r\n    /**\r\n     * Sets a callback to call before drawing the mesh. It is recommended to use onBeforeDrawObservable instead\r\n     */\r\n    public set onBeforeDraw(callback: () => void) {\r\n        if (this._onBeforeDrawObserver) {\r\n            this.onBeforeDrawObservable.remove(this._onBeforeDrawObserver);\r\n        }\r\n        this._onBeforeDrawObserver = this.onBeforeDrawObservable.add(callback);\r\n    }\r\n\r\n    public get hasInstances(): boolean {\r\n        return this.instances.length > 0;\r\n    }\r\n\r\n    public get hasThinInstances(): boolean {\r\n        return (this._thinInstanceDataStorage.instancesCount ?? 0) > 0;\r\n    }\r\n\r\n    // Members\r\n\r\n    /**\r\n     * Gets the delay loading state of the mesh (when delay loading is turned on)\r\n     * @see https://doc.babylonjs.com/how_to/using_the_incremental_loading_system\r\n     */\r\n    public delayLoadState = Constants.DELAYLOADSTATE_NONE;\r\n\r\n    /**\r\n     * Gets the list of instances created from this mesh\r\n     * it is not supposed to be modified manually.\r\n     * Note also that the order of the InstancedMesh wihin the array is not significant and might change.\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_instances\r\n     */\r\n    public instances = new Array<InstancedMesh>();\r\n\r\n    /**\r\n     * Gets the file containing delay loading data for this mesh\r\n     */\r\n    public delayLoadingFile: string;\r\n\r\n    /** @hidden */\r\n    public _binaryInfo: any;\r\n\r\n    /**\r\n     * User defined function used to change how LOD level selection is done\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_lod\r\n     */\r\n    public onLODLevelSelection: (distance: number, mesh: Mesh, selectedLevel: Nullable<Mesh>) => void;\r\n\r\n    // Private\r\n    /** @hidden */\r\n    public _creationDataStorage: Nullable<_CreationDataStorage> = null;\r\n\r\n    /** @hidden */\r\n    public _geometry: Nullable<Geometry> = null;\r\n    /** @hidden */\r\n    public _delayInfo: Array<string>;\r\n    /** @hidden */\r\n    public _delayLoadingFunction: (any: any, mesh: Mesh) => void;\r\n\r\n    /**\r\n     * Gets or sets the forced number of instances to display.\r\n     * If 0 (default value), the number of instances is not forced and depends on the draw type\r\n     * (regular / instance / thin instances mesh)\r\n     */\r\n    public get forcedInstanceCount(): number {\r\n        return this._internalMeshDataInfo._forcedInstanceCount;\r\n    }\r\n\r\n    public set forcedInstanceCount(count: number) {\r\n        this._internalMeshDataInfo._forcedInstanceCount = count;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _instanceDataStorage = new _InstanceDataStorage();\r\n\r\n    /** @hidden */\r\n    public _thinInstanceDataStorage = new _ThinInstanceDataStorage();\r\n\r\n    /** @hidden */\r\n    public _shouldGenerateFlatShading: boolean = false;\r\n\r\n    // Use by builder only to know what orientation were the mesh build in.\r\n    /** @hidden */\r\n    public _originalBuilderSideOrientation: number = Mesh.DEFAULTSIDE;\r\n\r\n    /**\r\n     * Use this property to change the original side orientation defined at construction time\r\n     */\r\n    public overrideMaterialSideOrientation: Nullable<number> = null;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating whether to render ignoring the active camera's max z setting. (false by default)\r\n     * Note this will reduce performance when set to true.\r\n     */\r\n    public ignoreCameraMaxZ = false;\r\n\r\n    /**\r\n     * Gets the source mesh (the one used to clone this one from)\r\n     */\r\n    public get source(): Nullable<Mesh> {\r\n        return this._internalMeshDataInfo._source;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of clones of this mesh\r\n     * The scene must have been constructed with useClonedMeshMap=true for this to work!\r\n     * Note that useClonedMeshMap=true is the default setting\r\n     */\r\n    public get cloneMeshMap(): Nullable<{ [id: string]: Mesh | undefined }> {\r\n        return this._internalMeshDataInfo.meshMap;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this mesh does not use index buffer\r\n     */\r\n    public get isUnIndexed(): boolean {\r\n        return this._unIndexed;\r\n    }\r\n\r\n    public set isUnIndexed(value: boolean) {\r\n        if (this._unIndexed !== value) {\r\n            this._unIndexed = value;\r\n            this._markSubMeshesAsAttributesDirty();\r\n        }\r\n    }\r\n\r\n    /** Gets the array buffer used to store the instanced buffer used for instances' world matrices */\r\n    public get worldMatrixInstancedBuffer() {\r\n        return this._instanceDataStorage.instancesData;\r\n    }\r\n\r\n    /** Gets the array buffer used to store the instanced buffer used for instances' previous world matrices */\r\n    public get previousWorldMatrixInstancedBuffer() {\r\n        return this._instanceDataStorage.instancesPreviousData;\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating that the update of the instance buffer of the world matrices is manual */\r\n    public get manualUpdateOfWorldMatrixInstancedBuffer() {\r\n        return this._instanceDataStorage.manualUpdate;\r\n    }\r\n\r\n    public set manualUpdateOfWorldMatrixInstancedBuffer(value: boolean) {\r\n        this._instanceDataStorage.manualUpdate = value;\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating that the update of the instance buffer of the world matrices is manual */\r\n    public get manualUpdateOfPreviousWorldMatrixInstancedBuffer() {\r\n        return this._instanceDataStorage.previousManualUpdate;\r\n    }\r\n\r\n    public set manualUpdateOfPreviousWorldMatrixInstancedBuffer(value: boolean) {\r\n        this._instanceDataStorage.previousManualUpdate = value;\r\n    }\r\n\r\n    /**\r\n     * @constructor\r\n     * @param name The value used by scene.getMeshByName() to do a lookup.\r\n     * @param scene The scene to add this mesh to.\r\n     * @param parent The parent of this mesh, if it has one\r\n     * @param source An optional Mesh from which geometry is shared, cloned.\r\n     * @param doNotCloneChildren When cloning, skip cloning child meshes of source, default False.\r\n     *                  When false, achieved by calling a clone(), also passing False.\r\n     *                  This will make creation of children, recursive.\r\n     * @param clonePhysicsImpostor When cloning, include cloning mesh physics impostor, default True.\r\n     */\r\n    constructor(\r\n        name: string,\r\n        scene: Nullable<Scene> = null,\r\n        parent: Nullable<Node> = null,\r\n        source: Nullable<Mesh> = null,\r\n        doNotCloneChildren?: boolean,\r\n        clonePhysicsImpostor: boolean = true\r\n    ) {\r\n        super(name, scene);\r\n\r\n        scene = this.getScene();\r\n\r\n        this._onBeforeDraw = (isInstance: boolean, world: Matrix, effectiveMaterial?: Material) => {\r\n            if (isInstance && effectiveMaterial) {\r\n                if (this._uniformBuffer) {\r\n                    this.transferToEffect(world);\r\n                } else {\r\n                    effectiveMaterial.bindOnlyWorldMatrix(world);\r\n                }\r\n            }\r\n        };\r\n\r\n        if (source) {\r\n            // Geometry\r\n            if (source._geometry) {\r\n                source._geometry.applyToMesh(this);\r\n            }\r\n\r\n            // Deep copy\r\n            DeepCopier.DeepCopy(\r\n                source,\r\n                this,\r\n                [\r\n                    \"name\",\r\n                    \"material\",\r\n                    \"skeleton\",\r\n                    \"instances\",\r\n                    \"parent\",\r\n                    \"uniqueId\",\r\n                    \"source\",\r\n                    \"metadata\",\r\n                    \"morphTargetManager\",\r\n                    \"hasInstances\",\r\n                    \"worldMatrixInstancedBuffer\",\r\n                    \"previousWorldMatrixInstancedBuffer\",\r\n                    \"hasLODLevels\",\r\n                    \"geometry\",\r\n                    \"isBlocked\",\r\n                    \"areNormalsFrozen\",\r\n                    \"facetNb\",\r\n                    \"isFacetDataEnabled\",\r\n                    \"lightSources\",\r\n                    \"useBones\",\r\n                    \"isAnInstance\",\r\n                    \"collider\",\r\n                    \"edgesRenderer\",\r\n                    \"forward\",\r\n                    \"up\",\r\n                    \"right\",\r\n                    \"absolutePosition\",\r\n                    \"absoluteScaling\",\r\n                    \"absoluteRotationQuaternion\",\r\n                    \"isWorldMatrixFrozen\",\r\n                    \"nonUniformScaling\",\r\n                    \"behaviors\",\r\n                    \"worldMatrixFromCache\",\r\n                    \"hasThinInstances\",\r\n                    \"cloneMeshMap\",\r\n                    \"hasBoundingInfo\",\r\n                ],\r\n                [\"_poseMatrix\"]\r\n            );\r\n\r\n            // Source mesh\r\n            this._internalMeshDataInfo._source = source;\r\n            if (scene.useClonedMeshMap) {\r\n                if (!source._internalMeshDataInfo.meshMap) {\r\n                    source._internalMeshDataInfo.meshMap = {};\r\n                }\r\n                source._internalMeshDataInfo.meshMap[this.uniqueId] = this;\r\n            }\r\n\r\n            // Construction Params\r\n            // Clone parameters allowing mesh to be updated in case of parametric shapes.\r\n            this._originalBuilderSideOrientation = source._originalBuilderSideOrientation;\r\n            this._creationDataStorage = source._creationDataStorage;\r\n\r\n            // Animation ranges\r\n            if (source._ranges) {\r\n                const ranges = source._ranges;\r\n                for (const name in ranges) {\r\n                    if (!Object.prototype.hasOwnProperty.call(ranges, name)) {\r\n                        continue;\r\n                    }\r\n\r\n                    if (!ranges[name]) {\r\n                        continue;\r\n                    }\r\n\r\n                    this.createAnimationRange(name, ranges[name]!.from, ranges[name]!.to);\r\n                }\r\n            }\r\n\r\n            // Metadata\r\n            if (source.metadata && source.metadata.clone) {\r\n                this.metadata = source.metadata.clone();\r\n            } else {\r\n                this.metadata = source.metadata;\r\n            }\r\n\r\n            // Tags\r\n            if (Tags && Tags.HasTags(source)) {\r\n                Tags.AddTagsTo(this, Tags.GetTags(source, true));\r\n            }\r\n\r\n            // Enabled\r\n            this.setEnabled(source.isEnabled());\r\n\r\n            // Parent\r\n            this.parent = source.parent;\r\n\r\n            // Pivot\r\n            this.setPivotMatrix(source.getPivotMatrix());\r\n\r\n            this.id = name + \".\" + source.id;\r\n\r\n            // Material\r\n            this.material = source.material;\r\n\r\n            if (!doNotCloneChildren) {\r\n                // Children\r\n                const directDescendants = source.getDescendants(true);\r\n                for (let index = 0; index < directDescendants.length; index++) {\r\n                    const child = directDescendants[index];\r\n\r\n                    if ((<any>child).clone) {\r\n                        (<any>child).clone(name + \".\" + child.name, this);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Morphs\r\n            if (source.morphTargetManager) {\r\n                this.morphTargetManager = source.morphTargetManager;\r\n            }\r\n\r\n            // Physics clone\r\n            if (scene.getPhysicsEngine) {\r\n                const physicsEngine = scene.getPhysicsEngine();\r\n                if (clonePhysicsImpostor && physicsEngine) {\r\n                    const impostor = physicsEngine.getImpostorForPhysicsObject(source);\r\n                    if (impostor) {\r\n                        this.physicsImpostor = impostor.clone(this);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Particles\r\n            for (let index = 0; index < scene.particleSystems.length; index++) {\r\n                const system = scene.particleSystems[index];\r\n\r\n                if (system.emitter === source) {\r\n                    system.clone(system.name, this);\r\n                }\r\n            }\r\n\r\n            // Skeleton\r\n            this.skeleton = source.skeleton;\r\n\r\n            this.refreshBoundingInfo(true, true);\r\n            this.computeWorldMatrix(true);\r\n        }\r\n\r\n        // Parent\r\n        if (parent !== null) {\r\n            this.parent = parent;\r\n        }\r\n\r\n        this._instanceDataStorage.hardwareInstancedRendering = this.getEngine().getCaps().instancedArrays;\r\n\r\n        this._internalMeshDataInfo._onMeshReadyObserverAdded = (observer: Observer<Mesh>) => {\r\n            // only notify once! then unregister the observer\r\n            observer.unregisterOnNextCall = true;\r\n            if (this.isReady(true)) {\r\n                this.onMeshReadyObservable.notifyObservers(this);\r\n            } else {\r\n                if (!this._internalMeshDataInfo._checkReadinessObserver) {\r\n                    this._internalMeshDataInfo._checkReadinessObserver = this._scene.onBeforeRenderObservable.add(() => {\r\n                        // check for complete readiness\r\n                        if (this.isReady(true)) {\r\n                            this._scene.onBeforeRenderObservable.remove(this._internalMeshDataInfo._checkReadinessObserver);\r\n                            this._internalMeshDataInfo._checkReadinessObserver = null;\r\n                            this.onMeshReadyObservable.notifyObservers(this);\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        };\r\n\r\n        this.onMeshReadyObservable = new Observable(this._internalMeshDataInfo._onMeshReadyObserverAdded);\r\n\r\n        if (source) {\r\n            source.onClonedObservable.notifyObservers(this);\r\n        }\r\n    }\r\n\r\n    public instantiateHierarchy(\r\n        newParent: Nullable<TransformNode> = null,\r\n        options?: { doNotInstantiate: boolean },\r\n        onNewNodeCreated?: (source: TransformNode, clone: TransformNode) => void\r\n    ): Nullable<TransformNode> {\r\n        const instance =\r\n            this.getTotalVertices() > 0 && (!options || !options.doNotInstantiate)\r\n                ? this.createInstance(\"instance of \" + (this.name || this.id))\r\n                : this.clone(\"Clone of \" + (this.name || this.id), newParent || this.parent, true);\r\n\r\n        instance.parent = newParent || this.parent;\r\n        instance.position = this.position.clone();\r\n        instance.scaling = this.scaling.clone();\r\n        if (this.rotationQuaternion) {\r\n            instance.rotationQuaternion = this.rotationQuaternion.clone();\r\n        } else {\r\n            instance.rotation = this.rotation.clone();\r\n        }\r\n\r\n        if (onNewNodeCreated) {\r\n            onNewNodeCreated(this, instance);\r\n        }\r\n\r\n        for (const child of this.getChildTransformNodes(true)) {\r\n            child.instantiateHierarchy(instance, options, onNewNodeCreated);\r\n        }\r\n\r\n        return instance;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name\r\n     * @returns the string \"Mesh\".\r\n     */\r\n    public getClassName(): string {\r\n        return \"Mesh\";\r\n    }\r\n\r\n    /** @hidden */\r\n    public get _isMesh() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns a description of this mesh\r\n     * @param fullDetails define if full details about this mesh must be used\r\n     * @returns a descriptive string representing this mesh\r\n     */\r\n    public toString(fullDetails?: boolean): string {\r\n        let ret = super.toString(fullDetails);\r\n        ret += \", n vertices: \" + this.getTotalVertices();\r\n        ret += \", parent: \" + (this._waitingParentId ? this._waitingParentId : this.parent ? this.parent.name : \"NONE\");\r\n\r\n        if (this.animations) {\r\n            for (let i = 0; i < this.animations.length; i++) {\r\n                ret += \", animation[0]: \" + this.animations[i].toString(fullDetails);\r\n            }\r\n        }\r\n\r\n        if (fullDetails) {\r\n            if (this._geometry) {\r\n                const ib = this.getIndices();\r\n                const vb = this.getVerticesData(VertexBuffer.PositionKind);\r\n\r\n                if (vb && ib) {\r\n                    ret += \", flat shading: \" + (vb.length / 3 === ib.length ? \"YES\" : \"NO\");\r\n                }\r\n            } else {\r\n                ret += \", flat shading: UNKNOWN\";\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _unBindEffect() {\r\n        super._unBindEffect();\r\n\r\n        for (const instance of this.instances) {\r\n            instance._unBindEffect();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this mesh has LOD\r\n     */\r\n    public get hasLODLevels(): boolean {\r\n        return this._internalMeshDataInfo._LODLevels.length > 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of MeshLODLevel associated with the current mesh\r\n     * @returns an array of MeshLODLevel\r\n     */\r\n    public getLODLevels(): MeshLODLevel[] {\r\n        return this._internalMeshDataInfo._LODLevels;\r\n    }\r\n\r\n    private _sortLODLevels(): void {\r\n        const sortingOrderFactor = this._internalMeshDataInfo._useLODScreenCoverage ? -1 : 1;\r\n        this._internalMeshDataInfo._LODLevels.sort((a, b) => {\r\n            if (a.distanceOrScreenCoverage < b.distanceOrScreenCoverage) {\r\n                return sortingOrderFactor;\r\n            }\r\n            if (a.distanceOrScreenCoverage > b.distanceOrScreenCoverage) {\r\n                return -sortingOrderFactor;\r\n            }\r\n\r\n            return 0;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Add a mesh as LOD level triggered at the given distance.\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_lod\r\n     * @param distanceOrScreenCoverage Either distance from the center of the object to show this level or the screen coverage if `useScreenCoverage` is set to `true`.\r\n     * If screen coverage, value is a fraction of the screen's total surface, between 0 and 1.\r\n     * @param mesh The mesh to be added as LOD level (can be null)\r\n     * @return This mesh (for chaining)\r\n     */\r\n    public addLODLevel(distanceOrScreenCoverage: number, mesh: Nullable<Mesh>): Mesh {\r\n        if (mesh && mesh._masterMesh) {\r\n            Logger.Warn(\"You cannot use a mesh as LOD level twice\");\r\n            return this;\r\n        }\r\n\r\n        const level = new MeshLODLevel(distanceOrScreenCoverage, mesh);\r\n        this._internalMeshDataInfo._LODLevels.push(level);\r\n\r\n        if (mesh) {\r\n            mesh._masterMesh = this;\r\n        }\r\n\r\n        this._sortLODLevels();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns the LOD level mesh at the passed distance or null if not found.\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_lod\r\n     * @param distance The distance from the center of the object to show this level\r\n     * @returns a Mesh or `null`\r\n     */\r\n    public getLODLevelAtDistance(distance: number): Nullable<Mesh> {\r\n        const internalDataInfo = this._internalMeshDataInfo;\r\n        for (let index = 0; index < internalDataInfo._LODLevels.length; index++) {\r\n            const level = internalDataInfo._LODLevels[index];\r\n\r\n            if (level.distanceOrScreenCoverage === distance) {\r\n                return level.mesh;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from the LOD array\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_lod\r\n     * @param mesh defines the mesh to be removed\r\n     * @return This mesh (for chaining)\r\n     */\r\n    public removeLODLevel(mesh: Mesh): Mesh {\r\n        const internalDataInfo = this._internalMeshDataInfo;\r\n        for (let index = 0; index < internalDataInfo._LODLevels.length; index++) {\r\n            if (internalDataInfo._LODLevels[index].mesh === mesh) {\r\n                internalDataInfo._LODLevels.splice(index, 1);\r\n                if (mesh) {\r\n                    mesh._masterMesh = null;\r\n                }\r\n            }\r\n        }\r\n\r\n        this._sortLODLevels();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns the registered LOD mesh distant from the parameter `camera` position if any, else returns the current mesh.\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_lod\r\n     * @param camera defines the camera to use to compute distance\r\n     * @param boundingSphere defines a custom bounding sphere to use instead of the one from this mesh\r\n     * @return This mesh (for chaining)\r\n     */\r\n    public getLOD(camera: Camera, boundingSphere?: BoundingSphere): Nullable<AbstractMesh> {\r\n        const internalDataInfo = this._internalMeshDataInfo;\r\n        if (!internalDataInfo._LODLevels || internalDataInfo._LODLevels.length === 0) {\r\n            return this;\r\n        }\r\n\r\n        let bSphere: BoundingSphere;\r\n\r\n        if (boundingSphere) {\r\n            bSphere = boundingSphere;\r\n        } else {\r\n            const boundingInfo = this.getBoundingInfo();\r\n\r\n            bSphere = boundingInfo.boundingSphere;\r\n        }\r\n\r\n        const distanceToCamera = bSphere.centerWorld.subtract(camera.globalPosition).length();\r\n        const useScreenCoverage = internalDataInfo._useLODScreenCoverage;\r\n        let compareValue = distanceToCamera;\r\n        let compareSign = 1;\r\n\r\n        if (useScreenCoverage) {\r\n            const screenArea = camera.screenArea;\r\n            let meshArea = (bSphere.radiusWorld * camera.minZ) / distanceToCamera;\r\n            meshArea = meshArea * meshArea * Math.PI;\r\n            compareValue = meshArea / screenArea;\r\n            compareSign = -1;\r\n        }\r\n\r\n        if (compareSign * internalDataInfo._LODLevels[internalDataInfo._LODLevels.length - 1].distanceOrScreenCoverage > compareSign * compareValue) {\r\n            if (this.onLODLevelSelection) {\r\n                this.onLODLevelSelection(compareValue, this, this);\r\n            }\r\n            return this;\r\n        }\r\n\r\n        for (let index = 0; index < internalDataInfo._LODLevels.length; index++) {\r\n            const level = internalDataInfo._LODLevels[index];\r\n\r\n            if (compareSign * level.distanceOrScreenCoverage < compareSign * compareValue) {\r\n                if (level.mesh) {\r\n                    if (level.mesh.delayLoadState === Constants.DELAYLOADSTATE_NOTLOADED) {\r\n                        level.mesh._checkDelayState();\r\n                        return this;\r\n                    }\r\n\r\n                    if (level.mesh.delayLoadState === Constants.DELAYLOADSTATE_LOADING) {\r\n                        return this;\r\n                    }\r\n\r\n                    level.mesh._preActivate();\r\n                    level.mesh._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);\r\n                }\r\n\r\n                if (this.onLODLevelSelection) {\r\n                    this.onLODLevelSelection(compareValue, this, level.mesh);\r\n                }\r\n\r\n                return level.mesh;\r\n            }\r\n        }\r\n\r\n        if (this.onLODLevelSelection) {\r\n            this.onLODLevelSelection(compareValue, this, this);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets the mesh internal Geometry object\r\n     */\r\n    public get geometry(): Nullable<Geometry> {\r\n        return this._geometry;\r\n    }\r\n\r\n    /**\r\n     * Returns the total number of vertices within the mesh geometry or zero if the mesh has no geometry.\r\n     * @returns the total number of vertices\r\n     */\r\n    public getTotalVertices(): number {\r\n        if (this._geometry === null || this._geometry === undefined) {\r\n            return 0;\r\n        }\r\n        return this._geometry.getTotalVertices();\r\n    }\r\n\r\n    /**\r\n     * Returns the content of an associated vertex buffer\r\n     * @param kind defines which buffer to read from (positions, indices, normals, etc). Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     * @param copyWhenShared defines a boolean indicating that if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one\r\n     * @param forceCopy defines a boolean forcing the copy of the buffer no matter what the value of copyWhenShared is\r\n     * @returns a FloatArray or null if the mesh has no geometry or no vertex buffer for this kind.\r\n     */\r\n    public getVerticesData(kind: string, copyWhenShared?: boolean, forceCopy?: boolean): Nullable<FloatArray> {\r\n        if (!this._geometry) {\r\n            return null;\r\n        }\r\n        let data = this._userInstancedBuffersStorage?.vertexBuffers[kind]?.getFloatData(\r\n            this._geometry.getTotalVertices(),\r\n            forceCopy || (copyWhenShared && this._geometry.meshes.length !== 1)\r\n        );\r\n        if (!data) {\r\n            data = this._geometry.getVerticesData(kind, copyWhenShared, forceCopy);\r\n        }\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns the mesh VertexBuffer object from the requested `kind`\r\n     * @param kind defines which buffer to read from (positions, indices, normals, etc). Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.NormalKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     * @returns a FloatArray or null if the mesh has no vertex buffer for this kind.\r\n     */\r\n    public getVertexBuffer(kind: string): Nullable<VertexBuffer> {\r\n        if (!this._geometry) {\r\n            return null;\r\n        }\r\n\r\n        return this._userInstancedBuffersStorage?.vertexBuffers[kind] ?? this._geometry.getVertexBuffer(kind);\r\n    }\r\n\r\n    /**\r\n     * Tests if a specific vertex buffer is associated with this mesh\r\n     * @param kind defines which buffer to check (positions, indices, normals, etc). Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.NormalKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     * @returns a boolean\r\n     */\r\n    public isVerticesDataPresent(kind: string): boolean {\r\n        if (!this._geometry) {\r\n            if (this._delayInfo) {\r\n                return this._delayInfo.indexOf(kind) !== -1;\r\n            }\r\n            return false;\r\n        }\r\n        return this._userInstancedBuffersStorage?.vertexBuffers[kind] !== undefined || this._geometry.isVerticesDataPresent(kind);\r\n    }\r\n\r\n    /**\r\n     * Returns a boolean defining if the vertex data for the requested `kind` is updatable.\r\n     * @param kind defines which buffer to check (positions, indices, normals, etc). Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     * @returns a boolean\r\n     */\r\n    public isVertexBufferUpdatable(kind: string): boolean {\r\n        if (!this._geometry) {\r\n            if (this._delayInfo) {\r\n                return this._delayInfo.indexOf(kind) !== -1;\r\n            }\r\n            return false;\r\n        }\r\n        return this._userInstancedBuffersStorage?.vertexBuffers[kind]?.isUpdatable() || this._geometry.isVertexBufferUpdatable(kind);\r\n    }\r\n\r\n    /**\r\n     * Returns a string which contains the list of existing `kinds` of Vertex Data associated with this mesh.\r\n     * @returns an array of strings\r\n     */\r\n    public getVerticesDataKinds(): string[] {\r\n        if (!this._geometry) {\r\n            const result = new Array<string>();\r\n            if (this._delayInfo) {\r\n                this._delayInfo.forEach(function (kind) {\r\n                    result.push(kind);\r\n                });\r\n            }\r\n            return result;\r\n        }\r\n        const kinds = this._geometry.getVerticesDataKinds();\r\n        if (this._userInstancedBuffersStorage) {\r\n            for (const kind in this._userInstancedBuffersStorage.vertexBuffers) {\r\n                kinds.push(kind);\r\n            }\r\n        }\r\n        return kinds;\r\n    }\r\n\r\n    /**\r\n     * Returns a positive integer : the total number of indices in this mesh geometry.\r\n     * @returns the numner of indices or zero if the mesh has no geometry.\r\n     */\r\n    public getTotalIndices(): number {\r\n        if (!this._geometry) {\r\n            return 0;\r\n        }\r\n        return this._geometry.getTotalIndices();\r\n    }\r\n\r\n    /**\r\n     * Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.\r\n     * @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.\r\n     * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\r\n     * @returns the indices array or an empty array if the mesh has no geometry\r\n     */\r\n    public getIndices(copyWhenShared?: boolean, forceCopy?: boolean): Nullable<IndicesArray> {\r\n        if (!this._geometry) {\r\n            return [];\r\n        }\r\n        return this._geometry.getIndices(copyWhenShared, forceCopy);\r\n    }\r\n\r\n    public get isBlocked(): boolean {\r\n        return this._masterMesh !== null && this._masterMesh !== undefined;\r\n    }\r\n\r\n    /**\r\n     * Determine if the current mesh is ready to be rendered\r\n     * @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)\r\n     * @param forceInstanceSupport will check if the mesh will be ready when used with instances (false by default)\r\n     * @returns true if all associated assets are ready (material, textures, shaders)\r\n     */\r\n    public isReady(completeCheck = false, forceInstanceSupport = false): boolean {\r\n        if (this.delayLoadState === Constants.DELAYLOADSTATE_LOADING) {\r\n            return false;\r\n        }\r\n\r\n        if (!super.isReady(completeCheck)) {\r\n            return false;\r\n        }\r\n\r\n        if (!this.subMeshes || this.subMeshes.length === 0) {\r\n            return true;\r\n        }\r\n\r\n        if (!completeCheck) {\r\n            return true;\r\n        }\r\n\r\n        const engine = this.getEngine();\r\n        const scene = this.getScene();\r\n        const hardwareInstancedRendering = forceInstanceSupport || (engine.getCaps().instancedArrays && (this.instances.length > 0 || this.hasThinInstances));\r\n\r\n        this.computeWorldMatrix();\r\n\r\n        const mat = this.material || scene.defaultMaterial;\r\n        if (mat) {\r\n            if (mat._storeEffectOnSubMeshes) {\r\n                for (const subMesh of this.subMeshes) {\r\n                    const effectiveMaterial = subMesh.getMaterial();\r\n                    if (effectiveMaterial) {\r\n                        if (effectiveMaterial._storeEffectOnSubMeshes) {\r\n                            if (!effectiveMaterial.isReadyForSubMesh(this, subMesh, hardwareInstancedRendering)) {\r\n                                return false;\r\n                            }\r\n                        } else {\r\n                            if (!effectiveMaterial.isReady(this, hardwareInstancedRendering)) {\r\n                                return false;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                if (!mat.isReady(this, hardwareInstancedRendering)) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Shadows\r\n        const currentRenderPassId = engine.currentRenderPassId;\r\n        for (const light of this.lightSources) {\r\n            const generator = light.getShadowGenerator();\r\n\r\n            if (generator && (!generator.getShadowMap()?.renderList || (generator.getShadowMap()?.renderList && generator.getShadowMap()?.renderList?.indexOf(this) !== -1))) {\r\n                if (generator.getShadowMap()) {\r\n                    engine.currentRenderPassId = generator.getShadowMap()!.renderPassId;\r\n                }\r\n                for (const subMesh of this.subMeshes) {\r\n                    if (!generator.isReady(subMesh, hardwareInstancedRendering, subMesh.getMaterial()?.needAlphaBlendingForMesh(this) ?? false)) {\r\n                        engine.currentRenderPassId = currentRenderPassId;\r\n                        return false;\r\n                    }\r\n                }\r\n                engine.currentRenderPassId = currentRenderPassId;\r\n            }\r\n        }\r\n\r\n        // LOD\r\n        for (const lod of this._internalMeshDataInfo._LODLevels) {\r\n            if (lod.mesh && !lod.mesh.isReady(hardwareInstancedRendering)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if the normals aren't to be recomputed on next mesh `positions` array update. This property is pertinent only for updatable parametric shapes.\r\n     */\r\n    public get areNormalsFrozen(): boolean {\r\n        return this._internalMeshDataInfo._areNormalsFrozen;\r\n    }\r\n\r\n    /**\r\n     * This function affects parametric shapes on vertex position update only : ribbons, tubes, etc. It has no effect at all on other shapes. It prevents the mesh normals from being recomputed on next `positions` array update.\r\n     * @returns the current mesh\r\n     */\r\n    public freezeNormals(): Mesh {\r\n        this._internalMeshDataInfo._areNormalsFrozen = true;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * This function affects parametric shapes on vertex position update only : ribbons, tubes, etc. It has no effect at all on other shapes. It reactivates the mesh normals computation if it was previously frozen\r\n     * @returns the current mesh\r\n     */\r\n    public unfreezeNormals(): Mesh {\r\n        this._internalMeshDataInfo._areNormalsFrozen = false;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a value overriding the instance count. Only applicable when custom instanced InterleavedVertexBuffer are used rather than InstancedMeshs\r\n     */\r\n    public set overridenInstanceCount(count: number) {\r\n        this._instanceDataStorage.overridenInstanceCount = count;\r\n    }\r\n\r\n    // Methods\r\n    /** @hidden */\r\n    public _preActivate(): Mesh {\r\n        const internalDataInfo = this._internalMeshDataInfo;\r\n        const sceneRenderId = this.getScene().getRenderId();\r\n        if (internalDataInfo._preActivateId === sceneRenderId) {\r\n            return this;\r\n        }\r\n\r\n        internalDataInfo._preActivateId = sceneRenderId;\r\n        this._instanceDataStorage.visibleInstances = null;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @param renderId\r\n     * @hidden\r\n     */\r\n    public _preActivateForIntermediateRendering(renderId: number): Mesh {\r\n        if (this._instanceDataStorage.visibleInstances) {\r\n            this._instanceDataStorage.visibleInstances.intermediateDefaultRenderId = renderId;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @param instance\r\n     * @param renderId\r\n     * @hidden\r\n     */\r\n    public _registerInstanceForRenderId(instance: InstancedMesh, renderId: number): Mesh {\r\n        if (!this._instanceDataStorage.visibleInstances) {\r\n            this._instanceDataStorage.visibleInstances = {\r\n                defaultRenderId: renderId,\r\n                selfDefaultRenderId: this._renderId,\r\n            };\r\n        }\r\n\r\n        if (!this._instanceDataStorage.visibleInstances[renderId]) {\r\n            if (this._instanceDataStorage.previousRenderId !== undefined && this._instanceDataStorage.isFrozen) {\r\n                this._instanceDataStorage.visibleInstances[this._instanceDataStorage.previousRenderId] = null;\r\n            }\r\n            this._instanceDataStorage.previousRenderId = renderId;\r\n            this._instanceDataStorage.visibleInstances[renderId] = new Array<InstancedMesh>();\r\n        }\r\n\r\n        this._instanceDataStorage.visibleInstances[renderId].push(instance);\r\n        return this;\r\n    }\r\n\r\n    protected _afterComputeWorldMatrix(): void {\r\n        super._afterComputeWorldMatrix();\r\n\r\n        if (!this.hasThinInstances) {\r\n            return;\r\n        }\r\n\r\n        if (!this.doNotSyncBoundingInfo) {\r\n            this.thinInstanceRefreshBoundingInfo(false);\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public _postActivate(): void {\r\n        if (this.edgesShareWithInstances && this.edgesRenderer && this.edgesRenderer.isEnabled && this._renderingGroup) {\r\n            this._renderingGroup._edgesRenderers.pushNoDuplicate(this.edgesRenderer);\r\n            this.edgesRenderer.customInstances.push(this.getWorldMatrix());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.\r\n     * This means the mesh underlying bounding box and sphere are recomputed.\r\n     * @param applySkeleton defines whether to apply the skeleton before computing the bounding info\r\n     * @param applyMorph  defines whether to apply the morph target before computing the bounding info\r\n     * @returns the current mesh\r\n     */\r\n    public refreshBoundingInfo(applySkeleton: boolean = false, applyMorph: boolean = false): Mesh {\r\n        if (this.hasBoundingInfo && this.getBoundingInfo().isLocked) {\r\n            return this;\r\n        }\r\n\r\n        const bias = this.geometry ? this.geometry.boundingBias : null;\r\n        this._refreshBoundingInfo(this._getPositionData(applySkeleton, applyMorph), bias);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @param force\r\n     * @hidden\r\n     */\r\n    public _createGlobalSubMesh(force: boolean): Nullable<SubMesh> {\r\n        const totalVertices = this.getTotalVertices();\r\n        if (!totalVertices || !this.getIndices()) {\r\n            return null;\r\n        }\r\n\r\n        // Check if we need to recreate the submeshes\r\n        if (this.subMeshes && this.subMeshes.length > 0) {\r\n            const ib = this.getIndices();\r\n\r\n            if (!ib) {\r\n                return null;\r\n            }\r\n\r\n            const totalIndices = ib.length;\r\n            let needToRecreate = false;\r\n\r\n            if (force) {\r\n                needToRecreate = true;\r\n            } else {\r\n                for (const submesh of this.subMeshes) {\r\n                    if (submesh.indexStart + submesh.indexCount > totalIndices) {\r\n                        needToRecreate = true;\r\n                        break;\r\n                    }\r\n\r\n                    if (submesh.verticesStart + submesh.verticesCount > totalVertices) {\r\n                        needToRecreate = true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (!needToRecreate) {\r\n                return this.subMeshes[0];\r\n            }\r\n        }\r\n\r\n        this.releaseSubMeshes();\r\n        return new SubMesh(0, 0, totalVertices, 0, this.getTotalIndices(), this);\r\n    }\r\n\r\n    /**\r\n     * This function will subdivide the mesh into multiple submeshes\r\n     * @param count defines the expected number of submeshes\r\n     */\r\n    public subdivide(count: number): void {\r\n        if (count < 1) {\r\n            return;\r\n        }\r\n\r\n        const totalIndices = this.getTotalIndices();\r\n        let subdivisionSize = (totalIndices / count) | 0;\r\n        let offset = 0;\r\n\r\n        // Ensure that subdivisionSize is a multiple of 3\r\n        while (subdivisionSize % 3 !== 0) {\r\n            subdivisionSize++;\r\n        }\r\n\r\n        this.releaseSubMeshes();\r\n        for (let index = 0; index < count; index++) {\r\n            if (offset >= totalIndices) {\r\n                break;\r\n            }\r\n\r\n            SubMesh.CreateFromIndices(0, offset, index === count - 1 ? totalIndices - offset : subdivisionSize, this);\r\n\r\n            offset += subdivisionSize;\r\n        }\r\n\r\n        this.synchronizeInstances();\r\n    }\r\n\r\n    /**\r\n     * Copy a FloatArray into a specific associated vertex buffer\r\n     * @param kind defines which buffer to write to (positions, indices, normals, etc). Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     * @param data defines the data source\r\n     * @param updatable defines if the updated vertex buffer must be flagged as updatable\r\n     * @param stride defines the data stride size (can be null)\r\n     * @returns the current mesh\r\n     */\r\n    public setVerticesData(kind: string, data: FloatArray, updatable: boolean = false, stride?: number): AbstractMesh {\r\n        if (!this._geometry) {\r\n            const vertexData = new VertexData();\r\n            vertexData.set(data, kind);\r\n\r\n            const scene = this.getScene();\r\n\r\n            new Geometry(Geometry.RandomId(), scene, vertexData, updatable, this);\r\n        } else {\r\n            this._geometry.setVerticesData(kind, data, updatable, stride);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Delete a vertex buffer associated with this mesh\r\n     * @param kind defines which buffer to delete (positions, indices, normals, etc). Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     */\r\n    public removeVerticesData(kind: string) {\r\n        if (!this._geometry) {\r\n            return;\r\n        }\r\n\r\n        this._geometry.removeVerticesData(kind);\r\n    }\r\n\r\n    /**\r\n     * Flags an associated vertex buffer as updatable\r\n     * @param kind defines which buffer to use (positions, indices, normals, etc). Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     * @param updatable defines if the updated vertex buffer must be flagged as updatable\r\n     */\r\n    public markVerticesDataAsUpdatable(kind: string, updatable = true) {\r\n        const vb = this.getVertexBuffer(kind);\r\n\r\n        if (!vb || vb.isUpdatable() === updatable) {\r\n            return;\r\n        }\r\n\r\n        this.setVerticesData(kind, <FloatArray>this.getVerticesData(kind), updatable);\r\n    }\r\n\r\n    /**\r\n     * Sets the mesh global Vertex Buffer\r\n     * @param buffer defines the buffer to use\r\n     * @param disposeExistingBuffer disposes the existing buffer, if any (default: true)\r\n     * @returns the current mesh\r\n     */\r\n    public setVerticesBuffer(buffer: VertexBuffer, disposeExistingBuffer = true): Mesh {\r\n        if (!this._geometry) {\r\n            this._geometry = Geometry.CreateGeometryForMesh(this);\r\n        }\r\n\r\n        this._geometry.setVerticesBuffer(buffer, null, disposeExistingBuffer);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Update a specific associated vertex buffer\r\n     * @param kind defines which buffer to write to (positions, indices, normals, etc). Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     * @param data defines the data source\r\n     * @param updateExtends defines if extends info of the mesh must be updated (can be null). This is mostly useful for \"position\" kind\r\n     * @param makeItUnique defines if the geometry associated with the mesh must be cloned to make the change only for this mesh (and not all meshes associated with the same geometry)\r\n     * @returns the current mesh\r\n     */\r\n    public updateVerticesData(kind: string, data: FloatArray, updateExtends?: boolean, makeItUnique?: boolean): AbstractMesh {\r\n        if (!this._geometry) {\r\n            return this;\r\n        }\r\n        if (!makeItUnique) {\r\n            this._geometry.updateVerticesData(kind, data, updateExtends);\r\n        } else {\r\n            this.makeGeometryUnique();\r\n            this.updateVerticesData(kind, data, updateExtends, false);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * This method updates the vertex positions of an updatable mesh according to the `positionFunction` returned values.\r\n     * @see https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#other-shapes-updatemeshpositions\r\n     * @param positionFunction is a simple JS function what is passed the mesh `positions` array. It doesn't need to return anything\r\n     * @param computeNormals is a boolean (default true) to enable/disable the mesh normal recomputation after the vertex position update\r\n     * @returns the current mesh\r\n     */\r\n    public updateMeshPositions(positionFunction: (data: FloatArray) => void, computeNormals: boolean = true): Mesh {\r\n        const positions = this.getVerticesData(VertexBuffer.PositionKind);\r\n        if (!positions) {\r\n            return this;\r\n        }\r\n\r\n        positionFunction(positions);\r\n        this.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);\r\n\r\n        if (computeNormals) {\r\n            const indices = this.getIndices();\r\n            const normals = this.getVerticesData(VertexBuffer.NormalKind);\r\n\r\n            if (!normals) {\r\n                return this;\r\n            }\r\n\r\n            VertexData.ComputeNormals(positions, indices, normals);\r\n            this.updateVerticesData(VertexBuffer.NormalKind, normals, false, false);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Creates a un-shared specific occurence of the geometry for the mesh.\r\n     * @returns the current mesh\r\n     */\r\n    public makeGeometryUnique(): Mesh {\r\n        if (!this._geometry) {\r\n            return this;\r\n        }\r\n\r\n        if (this._geometry.meshes.length === 1) {\r\n            return this;\r\n        }\r\n\r\n        const oldGeometry = this._geometry;\r\n        const geometry = this._geometry.copy(Geometry.RandomId());\r\n        oldGeometry.releaseForMesh(this, true);\r\n        geometry.applyToMesh(this);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set the index buffer of this mesh\r\n     * @param indices defines the source data\r\n     * @param totalVertices defines the total number of vertices referenced by this index data (can be null)\r\n     * @param updatable defines if the updated index buffer must be flagged as updatable (default is false)\r\n     * @returns the current mesh\r\n     */\r\n    public setIndices(indices: IndicesArray, totalVertices: Nullable<number> = null, updatable: boolean = false): AbstractMesh {\r\n        if (!this._geometry) {\r\n            const vertexData = new VertexData();\r\n            vertexData.indices = indices;\r\n\r\n            const scene = this.getScene();\r\n\r\n            new Geometry(Geometry.RandomId(), scene, vertexData, updatable, this);\r\n        } else {\r\n            this._geometry.setIndices(indices, totalVertices, updatable);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Update the current index buffer\r\n     * @param indices defines the source data\r\n     * @param offset defines the offset in the index buffer where to store the new data (can be null)\r\n     * @param gpuMemoryOnly defines a boolean indicating that only the GPU memory must be updated leaving the CPU version of the indices unchanged (false by default)\r\n     * @returns the current mesh\r\n     */\r\n    public updateIndices(indices: IndicesArray, offset?: number, gpuMemoryOnly = false): AbstractMesh {\r\n        if (!this._geometry) {\r\n            return this;\r\n        }\r\n\r\n        this._geometry.updateIndices(indices, offset, gpuMemoryOnly);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Invert the geometry to move from a right handed system to a left handed one.\r\n     * @returns the current mesh\r\n     */\r\n    public toLeftHanded(): Mesh {\r\n        if (!this._geometry) {\r\n            return this;\r\n        }\r\n        this._geometry.toLeftHanded();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @param subMesh\r\n     * @param effect\r\n     * @param fillMode\r\n     * @hidden\r\n     */\r\n    public _bind(subMesh: SubMesh, effect: Effect, fillMode: number): Mesh {\r\n        if (!this._geometry) {\r\n            return this;\r\n        }\r\n\r\n        const engine = this.getScene().getEngine();\r\n\r\n        // Morph targets\r\n        if (this.morphTargetManager && this.morphTargetManager.isUsingTextureForTargets) {\r\n            this.morphTargetManager._bind(effect);\r\n        }\r\n\r\n        // Wireframe\r\n        let indexToBind;\r\n\r\n        if (this._unIndexed) {\r\n            indexToBind = null;\r\n        } else {\r\n            switch (fillMode) {\r\n                case Material.PointFillMode:\r\n                    indexToBind = null;\r\n                    break;\r\n                case Material.WireFrameFillMode:\r\n                    indexToBind = subMesh._getLinesIndexBuffer(<IndicesArray>this.getIndices(), engine);\r\n                    break;\r\n                default:\r\n                case Material.TriangleFillMode:\r\n                    indexToBind = this._geometry.getIndexBuffer();\r\n                    break;\r\n            }\r\n        }\r\n\r\n        // VBOs\r\n        if (!this._userInstancedBuffersStorage || this.hasThinInstances) {\r\n            this._geometry._bind(effect, indexToBind);\r\n        } else {\r\n            this._geometry._bind(effect, indexToBind, this._userInstancedBuffersStorage.vertexBuffers, this._userInstancedBuffersStorage.vertexArrayObjects);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @param subMesh\r\n     * @param fillMode\r\n     * @param instancesCount\r\n     * @hidden\r\n     */\r\n    public _draw(subMesh: SubMesh, fillMode: number, instancesCount?: number): Mesh {\r\n        if (!this._geometry || !this._geometry.getVertexBuffers() || (!this._unIndexed && !this._geometry.getIndexBuffer())) {\r\n            return this;\r\n        }\r\n\r\n        if (this._internalMeshDataInfo._onBeforeDrawObservable) {\r\n            this._internalMeshDataInfo._onBeforeDrawObservable.notifyObservers(this);\r\n        }\r\n\r\n        const scene = this.getScene();\r\n        const engine = scene.getEngine();\r\n\r\n        if (this._unIndexed || fillMode == Material.PointFillMode) {\r\n            // or triangles as points\r\n            engine.drawArraysType(fillMode, subMesh.verticesStart, subMesh.verticesCount, this.forcedInstanceCount || instancesCount);\r\n        } else if (fillMode == Material.WireFrameFillMode) {\r\n            // Triangles as wireframe\r\n            engine.drawElementsType(fillMode, 0, subMesh._linesIndexCount, this.forcedInstanceCount || instancesCount);\r\n        } else {\r\n            engine.drawElementsType(fillMode, subMesh.indexStart, subMesh.indexCount, this.forcedInstanceCount || instancesCount);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Registers for this mesh a javascript function called just before the rendering process\r\n     * @param func defines the function to call before rendering this mesh\r\n     * @returns the current mesh\r\n     */\r\n    public registerBeforeRender(func: (mesh: AbstractMesh) => void): Mesh {\r\n        this.onBeforeRenderObservable.add(func);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Disposes a previously registered javascript function called before the rendering\r\n     * @param func defines the function to remove\r\n     * @returns the current mesh\r\n     */\r\n    public unregisterBeforeRender(func: (mesh: AbstractMesh) => void): Mesh {\r\n        this.onBeforeRenderObservable.removeCallback(func);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Registers for this mesh a javascript function called just after the rendering is complete\r\n     * @param func defines the function to call after rendering this mesh\r\n     * @returns the current mesh\r\n     */\r\n    public registerAfterRender(func: (mesh: AbstractMesh) => void): Mesh {\r\n        this.onAfterRenderObservable.add(func);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Disposes a previously registered javascript function called after the rendering.\r\n     * @param func defines the function to remove\r\n     * @returns the current mesh\r\n     */\r\n    public unregisterAfterRender(func: (mesh: AbstractMesh) => void): Mesh {\r\n        this.onAfterRenderObservable.removeCallback(func);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @param subMeshId\r\n     * @param isReplacementMode\r\n     * @hidden\r\n     */\r\n    public _getInstancesRenderList(subMeshId: number, isReplacementMode: boolean = false): _InstancesBatch {\r\n        if (this._instanceDataStorage.isFrozen) {\r\n            if (isReplacementMode) {\r\n                this._instanceDataStorage.batchCacheReplacementModeInFrozenMode.hardwareInstancedRendering[subMeshId] = false;\r\n                this._instanceDataStorage.batchCacheReplacementModeInFrozenMode.renderSelf[subMeshId] = true;\r\n                return this._instanceDataStorage.batchCacheReplacementModeInFrozenMode;\r\n            }\r\n            if (this._instanceDataStorage.previousBatch) {\r\n                return this._instanceDataStorage.previousBatch;\r\n            }\r\n        }\r\n        const scene = this.getScene();\r\n        const isInIntermediateRendering = scene._isInIntermediateRendering();\r\n        const onlyForInstances = isInIntermediateRendering\r\n            ? this._internalAbstractMeshDataInfo._onlyForInstancesIntermediate\r\n            : this._internalAbstractMeshDataInfo._onlyForInstances;\r\n        const batchCache = this._instanceDataStorage.batchCache;\r\n        batchCache.mustReturn = false;\r\n        batchCache.renderSelf[subMeshId] = isReplacementMode || (!onlyForInstances && this.isEnabled() && this.isVisible);\r\n        batchCache.visibleInstances[subMeshId] = null;\r\n\r\n        if (this._instanceDataStorage.visibleInstances && !isReplacementMode) {\r\n            const visibleInstances = this._instanceDataStorage.visibleInstances;\r\n            const currentRenderId = scene.getRenderId();\r\n            const defaultRenderId = isInIntermediateRendering ? visibleInstances.intermediateDefaultRenderId : visibleInstances.defaultRenderId;\r\n            batchCache.visibleInstances[subMeshId] = visibleInstances[currentRenderId];\r\n\r\n            if (!batchCache.visibleInstances[subMeshId] && defaultRenderId) {\r\n                batchCache.visibleInstances[subMeshId] = visibleInstances[defaultRenderId];\r\n            }\r\n        }\r\n        batchCache.hardwareInstancedRendering[subMeshId] =\r\n            !isReplacementMode &&\r\n            this._instanceDataStorage.hardwareInstancedRendering &&\r\n            batchCache.visibleInstances[subMeshId] !== null &&\r\n            batchCache.visibleInstances[subMeshId] !== undefined;\r\n        this._instanceDataStorage.previousBatch = batchCache;\r\n        return batchCache;\r\n    }\r\n\r\n    /**\r\n     * @param subMesh\r\n     * @param fillMode\r\n     * @param batch\r\n     * @param effect\r\n     * @param engine\r\n     * @hidden\r\n     */\r\n    public _renderWithInstances(subMesh: SubMesh, fillMode: number, batch: _InstancesBatch, effect: Effect, engine: Engine): Mesh {\r\n        const visibleInstances = batch.visibleInstances[subMesh._id];\r\n        if (!visibleInstances) {\r\n            return this;\r\n        }\r\n\r\n        const instanceStorage = this._instanceDataStorage;\r\n        const currentInstancesBufferSize = instanceStorage.instancesBufferSize;\r\n        let instancesBuffer = instanceStorage.instancesBuffer;\r\n        let instancesPreviousBuffer = instanceStorage.instancesPreviousBuffer;\r\n        const matricesCount = visibleInstances.length + 1;\r\n        const bufferSize = matricesCount * 16 * 4;\r\n\r\n        while (instanceStorage.instancesBufferSize < bufferSize) {\r\n            instanceStorage.instancesBufferSize *= 2;\r\n        }\r\n\r\n        if (!instanceStorage.instancesData || currentInstancesBufferSize != instanceStorage.instancesBufferSize) {\r\n            instanceStorage.instancesData = new Float32Array(instanceStorage.instancesBufferSize / 4);\r\n        }\r\n        if ((this._scene.needsPreviousWorldMatrices && !instanceStorage.instancesPreviousData) || currentInstancesBufferSize != instanceStorage.instancesBufferSize) {\r\n            instanceStorage.instancesPreviousData = new Float32Array(instanceStorage.instancesBufferSize / 4);\r\n        }\r\n\r\n        let offset = 0;\r\n        let instancesCount = 0;\r\n\r\n        const renderSelf = batch.renderSelf[subMesh._id];\r\n\r\n        const needUpdateBuffer =\r\n            !instancesBuffer ||\r\n            currentInstancesBufferSize !== instanceStorage.instancesBufferSize ||\r\n            (this._scene.needsPreviousWorldMatrices && !instanceStorage.instancesPreviousBuffer);\r\n\r\n        if (!this._instanceDataStorage.manualUpdate && (!instanceStorage.isFrozen || needUpdateBuffer)) {\r\n            const world = this.getWorldMatrix();\r\n            if (renderSelf) {\r\n                if (this._scene.needsPreviousWorldMatrices) {\r\n                    if (!instanceStorage.masterMeshPreviousWorldMatrix) {\r\n                        instanceStorage.masterMeshPreviousWorldMatrix = world.clone();\r\n                        instanceStorage.masterMeshPreviousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);\r\n                    } else {\r\n                        instanceStorage.masterMeshPreviousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);\r\n                        instanceStorage.masterMeshPreviousWorldMatrix.copyFrom(world);\r\n                    }\r\n                }\r\n                world.copyToArray(instanceStorage.instancesData, offset);\r\n                offset += 16;\r\n                instancesCount++;\r\n            }\r\n\r\n            if (visibleInstances) {\r\n                if (Mesh.INSTANCEDMESH_SORT_TRANSPARENT && this._scene.activeCamera && subMesh.getMaterial()?.needAlphaBlendingForMesh(subMesh.getRenderingMesh())) {\r\n                    const cameraPosition = this._scene.activeCamera.globalPosition;\r\n                    for (let instanceIndex = 0; instanceIndex < visibleInstances.length; instanceIndex++) {\r\n                        const instanceMesh = visibleInstances[instanceIndex];\r\n                        instanceMesh._distanceToCamera = Vector3.Distance(instanceMesh.getBoundingInfo().boundingSphere.centerWorld, cameraPosition);\r\n                    }\r\n                    visibleInstances.sort((m1, m2) => {\r\n                        return m1._distanceToCamera > m2._distanceToCamera ? -1 : m1._distanceToCamera < m2._distanceToCamera ? 1 : 0;\r\n                    });\r\n                }\r\n                for (let instanceIndex = 0; instanceIndex < visibleInstances.length; instanceIndex++) {\r\n                    const instance = visibleInstances[instanceIndex];\r\n                    const matrix = instance.getWorldMatrix();\r\n                    matrix.copyToArray(instanceStorage.instancesData, offset);\r\n\r\n                    if (this._scene.needsPreviousWorldMatrices) {\r\n                        if (!instance._previousWorldMatrix) {\r\n                            instance._previousWorldMatrix = matrix.clone();\r\n                            instance._previousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);\r\n                        } else {\r\n                            instance._previousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);\r\n                            instance._previousWorldMatrix.copyFrom(matrix);\r\n                        }\r\n                    }\r\n\r\n                    offset += 16;\r\n                    instancesCount++;\r\n                }\r\n            }\r\n        } else {\r\n            instancesCount = (renderSelf ? 1 : 0) + visibleInstances.length;\r\n        }\r\n\r\n        if (needUpdateBuffer) {\r\n            if (instancesBuffer) {\r\n                instancesBuffer.dispose();\r\n            }\r\n\r\n            if (instancesPreviousBuffer) {\r\n                instancesPreviousBuffer.dispose();\r\n            }\r\n\r\n            instancesBuffer = new Buffer(engine, instanceStorage.instancesData, true, 16, false, true);\r\n            instanceStorage.instancesBuffer = instancesBuffer;\r\n            if (!this._userInstancedBuffersStorage) {\r\n                this._userInstancedBuffersStorage = {\r\n                    data: {},\r\n                    vertexBuffers: {},\r\n                    strides: {},\r\n                    sizes: {},\r\n                    vertexArrayObjects: this.getEngine().getCaps().vertexArrayObject ? {} : undefined,\r\n                };\r\n            }\r\n\r\n            this._userInstancedBuffersStorage.vertexBuffers[\"world0\"] = instancesBuffer.createVertexBuffer(\"world0\", 0, 4);\r\n            this._userInstancedBuffersStorage.vertexBuffers[\"world1\"] = instancesBuffer.createVertexBuffer(\"world1\", 4, 4);\r\n            this._userInstancedBuffersStorage.vertexBuffers[\"world2\"] = instancesBuffer.createVertexBuffer(\"world2\", 8, 4);\r\n            this._userInstancedBuffersStorage.vertexBuffers[\"world3\"] = instancesBuffer.createVertexBuffer(\"world3\", 12, 4);\r\n\r\n            if (this._scene.needsPreviousWorldMatrices) {\r\n                instancesPreviousBuffer = new Buffer(engine, instanceStorage.instancesPreviousData, true, 16, false, true);\r\n                instanceStorage.instancesPreviousBuffer = instancesPreviousBuffer;\r\n\r\n                this._userInstancedBuffersStorage.vertexBuffers[\"previousWorld0\"] = instancesPreviousBuffer.createVertexBuffer(\"previousWorld0\", 0, 4);\r\n                this._userInstancedBuffersStorage.vertexBuffers[\"previousWorld1\"] = instancesPreviousBuffer.createVertexBuffer(\"previousWorld1\", 4, 4);\r\n                this._userInstancedBuffersStorage.vertexBuffers[\"previousWorld2\"] = instancesPreviousBuffer.createVertexBuffer(\"previousWorld2\", 8, 4);\r\n                this._userInstancedBuffersStorage.vertexBuffers[\"previousWorld3\"] = instancesPreviousBuffer.createVertexBuffer(\"previousWorld3\", 12, 4);\r\n            }\r\n            this._invalidateInstanceVertexArrayObject();\r\n        } else {\r\n            if (!this._instanceDataStorage.isFrozen) {\r\n                instancesBuffer!.updateDirectly(instanceStorage.instancesData, 0, instancesCount);\r\n                if (this._scene.needsPreviousWorldMatrices && (!this._instanceDataStorage.manualUpdate || this._instanceDataStorage.previousManualUpdate)) {\r\n                    instancesPreviousBuffer!.updateDirectly(instanceStorage.instancesPreviousData, 0, instancesCount);\r\n                }\r\n            }\r\n        }\r\n\r\n        this._processInstancedBuffers(visibleInstances, renderSelf);\r\n\r\n        // Stats\r\n        this.getScene()._activeIndices.addCount(subMesh.indexCount * instancesCount, false);\r\n\r\n        // Draw\r\n        if (engine._currentDrawContext) {\r\n            engine._currentDrawContext.useInstancing = true;\r\n        }\r\n        this._bind(subMesh, effect, fillMode);\r\n        this._draw(subMesh, fillMode, instancesCount);\r\n\r\n        // Write current matrices as previous matrices in case of manual update\r\n        // Default behaviour when previous matrices are not specified explicitly\r\n        // Will break if instances number/order changes\r\n        if (\r\n            this._scene.needsPreviousWorldMatrices &&\r\n            !needUpdateBuffer &&\r\n            this._instanceDataStorage.manualUpdate &&\r\n            !this._instanceDataStorage.isFrozen &&\r\n            !this._instanceDataStorage.previousManualUpdate\r\n        ) {\r\n            instancesPreviousBuffer!.updateDirectly(instanceStorage.instancesData, 0, instancesCount);\r\n        }\r\n\r\n        engine.unbindInstanceAttributes();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @param subMesh\r\n     * @param fillMode\r\n     * @param effect\r\n     * @param engine\r\n     * @hidden\r\n     */\r\n    public _renderWithThinInstances(subMesh: SubMesh, fillMode: number, effect: Effect, engine: Engine) {\r\n        // Stats\r\n        const instancesCount = this._thinInstanceDataStorage?.instancesCount ?? 0;\r\n\r\n        this.getScene()._activeIndices.addCount(subMesh.indexCount * instancesCount, false);\r\n\r\n        // Draw\r\n        if (engine._currentDrawContext) {\r\n            engine._currentDrawContext.useInstancing = true;\r\n        }\r\n        this._bind(subMesh, effect, fillMode);\r\n        this._draw(subMesh, fillMode, instancesCount);\r\n\r\n        // Write current matrices as previous matrices\r\n        // Default behaviour when previous matrices are not specified explicitly\r\n        // Will break if instances number/order changes\r\n        if (this._scene.needsPreviousWorldMatrices && !this._thinInstanceDataStorage.previousMatrixData && this._thinInstanceDataStorage.matrixData) {\r\n            if (!this._thinInstanceDataStorage.previousMatrixBuffer) {\r\n                this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer(\"previousWorld\", this._thinInstanceDataStorage.matrixData, false);\r\n            } else {\r\n                this._thinInstanceDataStorage.previousMatrixBuffer!.updateDirectly(this._thinInstanceDataStorage.matrixData, 0, instancesCount);\r\n            }\r\n        }\r\n\r\n        engine.unbindInstanceAttributes();\r\n    }\r\n\r\n    /**\r\n     * @param visibleInstances\r\n     * @param renderSelf\r\n     * @hidden\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public _processInstancedBuffers(visibleInstances: InstancedMesh[], renderSelf: boolean) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * @param renderingMesh\r\n     * @param subMesh\r\n     * @param effect\r\n     * @param fillMode\r\n     * @param batch\r\n     * @param hardwareInstancedRendering\r\n     * @param onBeforeDraw\r\n     * @param effectiveMaterial\r\n     * @hidden\r\n     */\r\n    public _processRendering(\r\n        renderingMesh: AbstractMesh,\r\n        subMesh: SubMesh,\r\n        effect: Effect,\r\n        fillMode: number,\r\n        batch: _InstancesBatch,\r\n        hardwareInstancedRendering: boolean,\r\n        onBeforeDraw: (isInstance: boolean, world: Matrix, effectiveMaterial?: Material) => void,\r\n        effectiveMaterial?: Material\r\n    ): Mesh {\r\n        const scene = this.getScene();\r\n        const engine = scene.getEngine();\r\n\r\n        if (hardwareInstancedRendering && subMesh.getRenderingMesh().hasThinInstances) {\r\n            this._renderWithThinInstances(subMesh, fillMode, effect, engine);\r\n            return this;\r\n        }\r\n\r\n        if (hardwareInstancedRendering) {\r\n            this._renderWithInstances(subMesh, fillMode, batch, effect, engine);\r\n        } else {\r\n            if (engine._currentDrawContext) {\r\n                engine._currentDrawContext.useInstancing = false;\r\n            }\r\n\r\n            let instanceCount = 0;\r\n            if (batch.renderSelf[subMesh._id]) {\r\n                // Draw\r\n                if (onBeforeDraw) {\r\n                    onBeforeDraw(false, renderingMesh.getWorldMatrix(), effectiveMaterial);\r\n                }\r\n                instanceCount++;\r\n\r\n                this._draw(subMesh, fillMode, this._instanceDataStorage.overridenInstanceCount);\r\n            }\r\n\r\n            const visibleInstancesForSubMesh = batch.visibleInstances[subMesh._id];\r\n\r\n            if (visibleInstancesForSubMesh) {\r\n                const visibleInstanceCount = visibleInstancesForSubMesh.length;\r\n                instanceCount += visibleInstanceCount;\r\n\r\n                // Stats\r\n                for (let instanceIndex = 0; instanceIndex < visibleInstanceCount; instanceIndex++) {\r\n                    const instance = visibleInstancesForSubMesh[instanceIndex];\r\n\r\n                    // World\r\n                    const world = instance.getWorldMatrix();\r\n                    if (onBeforeDraw) {\r\n                        onBeforeDraw(true, world, effectiveMaterial);\r\n                    }\r\n                    // Draw\r\n                    this._draw(subMesh, fillMode);\r\n                }\r\n            }\r\n\r\n            // Stats\r\n            scene._activeIndices.addCount(subMesh.indexCount * instanceCount, false);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @param dispose\r\n     * @hidden\r\n     */\r\n    public _rebuild(dispose = false): void {\r\n        if (this._instanceDataStorage.instancesBuffer) {\r\n            // Dispose instance buffer to be recreated in _renderWithInstances when rendered\r\n            if (dispose) {\r\n                this._instanceDataStorage.instancesBuffer.dispose();\r\n            }\r\n            this._instanceDataStorage.instancesBuffer = null;\r\n        }\r\n        if (this._userInstancedBuffersStorage) {\r\n            for (const kind in this._userInstancedBuffersStorage.vertexBuffers) {\r\n                const buffer = this._userInstancedBuffersStorage.vertexBuffers[kind];\r\n                if (buffer) {\r\n                    // Dispose instance buffer to be recreated in _renderWithInstances when rendered\r\n                    if (dispose) {\r\n                        buffer.dispose();\r\n                    }\r\n                    this._userInstancedBuffersStorage.vertexBuffers[kind] = null;\r\n                }\r\n            }\r\n            if (this._userInstancedBuffersStorage.vertexArrayObjects) {\r\n                this._userInstancedBuffersStorage.vertexArrayObjects = {};\r\n            }\r\n        }\r\n        this._internalMeshDataInfo._effectiveMaterial = null;\r\n        super._rebuild(dispose);\r\n    }\r\n\r\n    /** @hidden */\r\n    public _freeze() {\r\n        if (!this.subMeshes) {\r\n            return;\r\n        }\r\n\r\n        // Prepare batches\r\n        for (let index = 0; index < this.subMeshes.length; index++) {\r\n            this._getInstancesRenderList(index);\r\n        }\r\n\r\n        this._internalMeshDataInfo._effectiveMaterial = null;\r\n        this._instanceDataStorage.isFrozen = true;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _unFreeze() {\r\n        this._instanceDataStorage.isFrozen = false;\r\n        this._instanceDataStorage.previousBatch = null;\r\n    }\r\n\r\n    /**\r\n     * Triggers the draw call for the mesh. Usually, you don't need to call this method by your own because the mesh rendering is handled by the scene rendering manager\r\n     * @param subMesh defines the subMesh to render\r\n     * @param enableAlphaMode defines if alpha mode can be changed\r\n     * @param effectiveMeshReplacement defines an optional mesh used to provide info for the rendering\r\n     * @returns the current mesh\r\n     */\r\n    public render(subMesh: SubMesh, enableAlphaMode: boolean, effectiveMeshReplacement?: AbstractMesh): Mesh {\r\n        const scene = this.getScene();\r\n\r\n        if (this._internalAbstractMeshDataInfo._isActiveIntermediate) {\r\n            this._internalAbstractMeshDataInfo._isActiveIntermediate = false;\r\n        } else {\r\n            this._internalAbstractMeshDataInfo._isActive = false;\r\n        }\r\n\r\n        if (this._checkOcclusionQuery() && !this._occlusionDataStorage.forceRenderingWhenOccluded) {\r\n            return this;\r\n        }\r\n\r\n        // Managing instances\r\n        const batch = this._getInstancesRenderList(subMesh._id, !!effectiveMeshReplacement);\r\n\r\n        if (batch.mustReturn) {\r\n            return this;\r\n        }\r\n\r\n        // Checking geometry state\r\n        if (!this._geometry || !this._geometry.getVertexBuffers() || (!this._unIndexed && !this._geometry.getIndexBuffer())) {\r\n            return this;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n        let oldCameraMaxZ = 0;\r\n        let oldCamera: Nullable<Camera> = null;\r\n        if (this.ignoreCameraMaxZ && scene.activeCamera && !scene._isInIntermediateRendering()) {\r\n            oldCameraMaxZ = scene.activeCamera.maxZ;\r\n            oldCamera = scene.activeCamera;\r\n            scene.activeCamera.maxZ = 0;\r\n            scene.updateTransformMatrix(true);\r\n        }\r\n\r\n        if (this._internalMeshDataInfo._onBeforeRenderObservable) {\r\n            this._internalMeshDataInfo._onBeforeRenderObservable.notifyObservers(this);\r\n        }\r\n\r\n        const hardwareInstancedRendering = batch.hardwareInstancedRendering[subMesh._id] || subMesh.getRenderingMesh().hasThinInstances;\r\n        const instanceDataStorage = this._instanceDataStorage;\r\n\r\n        const material = subMesh.getMaterial();\r\n        if (!material) {\r\n            if (oldCamera) {\r\n                oldCamera.maxZ = oldCameraMaxZ;\r\n                scene.updateTransformMatrix(true);\r\n            }\r\n            return this;\r\n        }\r\n\r\n        // Material\r\n        if (!instanceDataStorage.isFrozen || !this._internalMeshDataInfo._effectiveMaterial || this._internalMeshDataInfo._effectiveMaterial !== material) {\r\n            if (material._storeEffectOnSubMeshes) {\r\n                if (!material.isReadyForSubMesh(this, subMesh, hardwareInstancedRendering)) {\r\n                    if (oldCamera) {\r\n                        oldCamera.maxZ = oldCameraMaxZ;\r\n                        scene.updateTransformMatrix(true);\r\n                    }\r\n                    return this;\r\n                }\r\n            } else if (!material.isReady(this, hardwareInstancedRendering)) {\r\n                if (oldCamera) {\r\n                    oldCamera.maxZ = oldCameraMaxZ;\r\n                    scene.updateTransformMatrix(true);\r\n                }\r\n                return this;\r\n            }\r\n\r\n            this._internalMeshDataInfo._effectiveMaterial = material;\r\n        } else if (\r\n            (material._storeEffectOnSubMeshes && !subMesh.effect?._wasPreviouslyReady) ||\r\n            (!material._storeEffectOnSubMeshes && !material.getEffect()?._wasPreviouslyReady)\r\n        ) {\r\n            if (oldCamera) {\r\n                oldCamera.maxZ = oldCameraMaxZ;\r\n                scene.updateTransformMatrix(true);\r\n            }\r\n            return this;\r\n        }\r\n\r\n        // Alpha mode\r\n        if (enableAlphaMode) {\r\n            engine.setAlphaMode(this._internalMeshDataInfo._effectiveMaterial.alphaMode);\r\n        }\r\n\r\n        let drawWrapper: Nullable<DrawWrapper>;\r\n        if (this._internalMeshDataInfo._effectiveMaterial._storeEffectOnSubMeshes) {\r\n            drawWrapper = subMesh._drawWrapper;\r\n        } else {\r\n            drawWrapper = this._internalMeshDataInfo._effectiveMaterial._getDrawWrapper();\r\n        }\r\n\r\n        const effect = drawWrapper?.effect ?? null;\r\n\r\n        for (const step of scene._beforeRenderingMeshStage) {\r\n            step.action(this, subMesh, batch, effect);\r\n        }\r\n\r\n        if (!drawWrapper || !effect) {\r\n            if (oldCamera) {\r\n                oldCamera.maxZ = oldCameraMaxZ;\r\n                scene.updateTransformMatrix(true);\r\n            }\r\n            return this;\r\n        }\r\n\r\n        const effectiveMesh = effectiveMeshReplacement || this;\r\n\r\n        let sideOrientation: Nullable<number>;\r\n\r\n        if (!instanceDataStorage.isFrozen && (this._internalMeshDataInfo._effectiveMaterial.backFaceCulling || this.overrideMaterialSideOrientation !== null)) {\r\n            const mainDeterminant = effectiveMesh._getWorldMatrixDeterminant();\r\n            sideOrientation = this.overrideMaterialSideOrientation;\r\n            if (sideOrientation == null) {\r\n                sideOrientation = this._internalMeshDataInfo._effectiveMaterial.sideOrientation;\r\n            }\r\n            if (mainDeterminant < 0) {\r\n                sideOrientation = sideOrientation === Material.ClockWiseSideOrientation ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\r\n            }\r\n            instanceDataStorage.sideOrientation = sideOrientation!;\r\n        } else {\r\n            sideOrientation = instanceDataStorage.sideOrientation;\r\n        }\r\n\r\n        const reverse = this._internalMeshDataInfo._effectiveMaterial._preBind(drawWrapper, sideOrientation);\r\n\r\n        if (this._internalMeshDataInfo._effectiveMaterial.forceDepthWrite) {\r\n            engine.setDepthWrite(true);\r\n        }\r\n\r\n        // Bind\r\n        const fillMode = scene.forcePointsCloud\r\n            ? Material.PointFillMode\r\n            : scene.forceWireframe\r\n            ? Material.WireFrameFillMode\r\n            : this._internalMeshDataInfo._effectiveMaterial.fillMode;\r\n\r\n        if (this._internalMeshDataInfo._onBeforeBindObservable) {\r\n            this._internalMeshDataInfo._onBeforeBindObservable.notifyObservers(this);\r\n        }\r\n\r\n        if (!hardwareInstancedRendering) {\r\n            // Binding will be done later because we need to add more info to the VB\r\n            this._bind(subMesh, effect, fillMode);\r\n        }\r\n\r\n        const effectiveMaterial = this._internalMeshDataInfo._effectiveMaterial;\r\n        const world = effectiveMesh.getWorldMatrix();\r\n        if (effectiveMaterial._storeEffectOnSubMeshes) {\r\n            effectiveMaterial.bindForSubMesh(world, this, subMesh);\r\n        } else {\r\n            effectiveMaterial.bind(world, this);\r\n        }\r\n\r\n        if (!effectiveMaterial.backFaceCulling && effectiveMaterial.separateCullingPass) {\r\n            engine.setState(true, effectiveMaterial.zOffset, false, !reverse, effectiveMaterial.cullBackFaces, effectiveMaterial.stencil, effectiveMaterial.zOffsetUnits);\r\n            this._processRendering(this, subMesh, effect, fillMode, batch, hardwareInstancedRendering, this._onBeforeDraw, this._internalMeshDataInfo._effectiveMaterial);\r\n            engine.setState(true, effectiveMaterial.zOffset, false, reverse, effectiveMaterial.cullBackFaces, effectiveMaterial.stencil, effectiveMaterial.zOffsetUnits);\r\n\r\n            if (this._internalMeshDataInfo._onBetweenPassObservable) {\r\n                this._internalMeshDataInfo._onBetweenPassObservable.notifyObservers(subMesh);\r\n            }\r\n        }\r\n\r\n        // Draw\r\n        this._processRendering(this, subMesh, effect, fillMode, batch, hardwareInstancedRendering, this._onBeforeDraw, this._internalMeshDataInfo._effectiveMaterial);\r\n\r\n        // Unbind\r\n        this._internalMeshDataInfo._effectiveMaterial.unbind();\r\n\r\n        for (const step of scene._afterRenderingMeshStage) {\r\n            step.action(this, subMesh, batch, effect);\r\n        }\r\n\r\n        if (this._internalMeshDataInfo._onAfterRenderObservable) {\r\n            this._internalMeshDataInfo._onAfterRenderObservable.notifyObservers(this);\r\n        }\r\n\r\n        if (oldCamera) {\r\n            oldCamera.maxZ = oldCameraMaxZ;\r\n            scene.updateTransformMatrix(true);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    private _onBeforeDraw: (isInstance: boolean, world: Matrix, effectiveMaterial?: Material) => void;\r\n\r\n    /**\r\n     *   Renormalize the mesh and patch it up if there are no weights\r\n     *   Similar to normalization by adding the weights compute the reciprocal and multiply all elements, this wil ensure that everything adds to 1.\r\n     *   However in the case of zero weights then we set just a single influence to 1.\r\n     *   We check in the function for extra's present and if so we use the normalizeSkinWeightsWithExtras rather than the FourWeights version.\r\n     */\r\n    public cleanMatrixWeights(): void {\r\n        if (this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {\r\n            if (this.isVerticesDataPresent(VertexBuffer.MatricesWeightsExtraKind)) {\r\n                this._normalizeSkinWeightsAndExtra();\r\n            } else {\r\n                this._normalizeSkinFourWeights();\r\n            }\r\n        }\r\n    }\r\n\r\n    // faster 4 weight version.\r\n    private _normalizeSkinFourWeights(): void {\r\n        const matricesWeights = <FloatArray>this.getVerticesData(VertexBuffer.MatricesWeightsKind);\r\n        const numWeights = matricesWeights.length;\r\n\r\n        for (let a = 0; a < numWeights; a += 4) {\r\n            // accumulate weights\r\n            const t = matricesWeights[a] + matricesWeights[a + 1] + matricesWeights[a + 2] + matricesWeights[a + 3];\r\n            // check for invalid weight and just set it to 1.\r\n            if (t === 0) {\r\n                matricesWeights[a] = 1;\r\n            } else {\r\n                // renormalize so everything adds to 1 use reciprocal\r\n                const recip = 1 / t;\r\n                matricesWeights[a] *= recip;\r\n                matricesWeights[a + 1] *= recip;\r\n                matricesWeights[a + 2] *= recip;\r\n                matricesWeights[a + 3] *= recip;\r\n            }\r\n        }\r\n        this.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeights);\r\n    }\r\n    // handle special case of extra verts.  (in theory gltf can handle 12 influences)\r\n    private _normalizeSkinWeightsAndExtra(): void {\r\n        const matricesWeightsExtra = <FloatArray>this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind);\r\n        const matricesWeights = <FloatArray>this.getVerticesData(VertexBuffer.MatricesWeightsKind);\r\n        const numWeights = matricesWeights.length;\r\n\r\n        for (let a = 0; a < numWeights; a += 4) {\r\n            // accumulate weights\r\n            let t = matricesWeights[a] + matricesWeights[a + 1] + matricesWeights[a + 2] + matricesWeights[a + 3];\r\n            t += matricesWeightsExtra[a] + matricesWeightsExtra[a + 1] + matricesWeightsExtra[a + 2] + matricesWeightsExtra[a + 3];\r\n            // check for invalid weight and just set it to 1.\r\n            if (t === 0) {\r\n                matricesWeights[a] = 1;\r\n            } else {\r\n                // renormalize so everything adds to 1 use reciprocal\r\n                const recip = 1 / t;\r\n                matricesWeights[a] *= recip;\r\n                matricesWeights[a + 1] *= recip;\r\n                matricesWeights[a + 2] *= recip;\r\n                matricesWeights[a + 3] *= recip;\r\n                // same goes for extras\r\n                matricesWeightsExtra[a] *= recip;\r\n                matricesWeightsExtra[a + 1] *= recip;\r\n                matricesWeightsExtra[a + 2] *= recip;\r\n                matricesWeightsExtra[a + 3] *= recip;\r\n            }\r\n        }\r\n        this.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeights);\r\n        this.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeightsExtra);\r\n    }\r\n\r\n    /**\r\n     * ValidateSkinning is used to determine that a mesh has valid skinning data along with skin metrics, if missing weights,\r\n     * or not normalized it is returned as invalid mesh the string can be used for console logs, or on screen messages to let\r\n     * the user know there was an issue with importing the mesh\r\n     * @returns a validation object with skinned, valid and report string\r\n     */\r\n    public validateSkinning(): { skinned: boolean; valid: boolean; report: string } {\r\n        const matricesWeightsExtra = <FloatArray>this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind);\r\n        const matricesWeights = <FloatArray>this.getVerticesData(VertexBuffer.MatricesWeightsKind);\r\n        if (matricesWeights === null || this.skeleton == null) {\r\n            return { skinned: false, valid: true, report: \"not skinned\" };\r\n        }\r\n\r\n        const numWeights = matricesWeights.length;\r\n        let numberNotSorted: number = 0;\r\n        let missingWeights: number = 0;\r\n        let maxUsedWeights: number = 0;\r\n        let numberNotNormalized: number = 0;\r\n        const numInfluences: number = matricesWeightsExtra === null ? 4 : 8;\r\n        const usedWeightCounts = new Array<number>();\r\n        for (let a = 0; a <= numInfluences; a++) {\r\n            usedWeightCounts[a] = 0;\r\n        }\r\n        const toleranceEpsilon: number = 0.001;\r\n\r\n        for (let a = 0; a < numWeights; a += 4) {\r\n            let lastWeight: number = matricesWeights[a];\r\n            let t = lastWeight;\r\n            let usedWeights: number = t === 0 ? 0 : 1;\r\n\r\n            for (let b = 1; b < numInfluences; b++) {\r\n                const d = b < 4 ? matricesWeights[a + b] : matricesWeightsExtra[a + b - 4];\r\n                if (d > lastWeight) {\r\n                    numberNotSorted++;\r\n                }\r\n                if (d !== 0) {\r\n                    usedWeights++;\r\n                }\r\n                t += d;\r\n                lastWeight = d;\r\n            }\r\n            // count the buffer weights usage\r\n            usedWeightCounts[usedWeights]++;\r\n\r\n            // max influences\r\n            if (usedWeights > maxUsedWeights) {\r\n                maxUsedWeights = usedWeights;\r\n            }\r\n\r\n            // check for invalid weight and just set it to 1.\r\n            if (t === 0) {\r\n                missingWeights++;\r\n            } else {\r\n                // renormalize so everything adds to 1 use reciprocal\r\n                const recip = 1 / t;\r\n                let tolerance = 0;\r\n                for (let b = 0; b < numInfluences; b++) {\r\n                    if (b < 4) {\r\n                        tolerance += Math.abs(matricesWeights[a + b] - matricesWeights[a + b] * recip);\r\n                    } else {\r\n                        tolerance += Math.abs(matricesWeightsExtra[a + b - 4] - matricesWeightsExtra[a + b - 4] * recip);\r\n                    }\r\n                }\r\n                // arbitrary epsilon value for dictating not normalized\r\n                if (tolerance > toleranceEpsilon) {\r\n                    numberNotNormalized++;\r\n                }\r\n            }\r\n        }\r\n\r\n        // validate bone indices are in range of the skeleton\r\n        const numBones: number = this.skeleton.bones.length;\r\n        const matricesIndices = <FloatArray>this.getVerticesData(VertexBuffer.MatricesIndicesKind);\r\n        const matricesIndicesExtra = <FloatArray>this.getVerticesData(VertexBuffer.MatricesIndicesExtraKind);\r\n        let numBadBoneIndices: number = 0;\r\n        for (let a = 0; a < numWeights; a += 4) {\r\n            for (let b = 0; b < numInfluences; b++) {\r\n                const index = b < 4 ? matricesIndices[a + b] : matricesIndicesExtra[a + b - 4];\r\n                if (index >= numBones || index < 0) {\r\n                    numBadBoneIndices++;\r\n                }\r\n            }\r\n        }\r\n\r\n        // log mesh stats\r\n        const output =\r\n            \"Number of Weights = \" +\r\n            numWeights / 4 +\r\n            \"\\nMaximum influences = \" +\r\n            maxUsedWeights +\r\n            \"\\nMissing Weights = \" +\r\n            missingWeights +\r\n            \"\\nNot Sorted = \" +\r\n            numberNotSorted +\r\n            \"\\nNot Normalized = \" +\r\n            numberNotNormalized +\r\n            \"\\nWeightCounts = [\" +\r\n            usedWeightCounts +\r\n            \"]\" +\r\n            \"\\nNumber of bones = \" +\r\n            numBones +\r\n            \"\\nBad Bone Indices = \" +\r\n            numBadBoneIndices;\r\n\r\n        return { skinned: true, valid: missingWeights === 0 && numberNotNormalized === 0 && numBadBoneIndices === 0, report: output };\r\n    }\r\n\r\n    /** @hidden */\r\n    public _checkDelayState(): Mesh {\r\n        const scene = this.getScene();\r\n        if (this._geometry) {\r\n            this._geometry.load(scene);\r\n        } else if (this.delayLoadState === Constants.DELAYLOADSTATE_NOTLOADED) {\r\n            this.delayLoadState = Constants.DELAYLOADSTATE_LOADING;\r\n\r\n            this._queueLoad(scene);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    private _queueLoad(scene: Scene): Mesh {\r\n        scene._addPendingData(this);\r\n\r\n        const getBinaryData = this.delayLoadingFile.indexOf(\".babylonbinarymeshdata\") !== -1;\r\n\r\n        Tools.LoadFile(\r\n            this.delayLoadingFile,\r\n            (data) => {\r\n                if (data instanceof ArrayBuffer) {\r\n                    this._delayLoadingFunction(data, this);\r\n                } else {\r\n                    this._delayLoadingFunction(JSON.parse(data), this);\r\n                }\r\n\r\n                this.instances.forEach((instance) => {\r\n                    instance.refreshBoundingInfo();\r\n                    instance._syncSubMeshes();\r\n                });\r\n\r\n                this.delayLoadState = Constants.DELAYLOADSTATE_LOADED;\r\n                scene._removePendingData(this);\r\n            },\r\n            () => {},\r\n            scene.offlineProvider,\r\n            getBinaryData\r\n        );\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns `true` if the mesh is within the frustum defined by the passed array of planes.\r\n     * A mesh is in the frustum if its bounding box intersects the frustum\r\n     * @param frustumPlanes defines the frustum to test\r\n     * @returns true if the mesh is in the frustum planes\r\n     */\r\n    public isInFrustum(frustumPlanes: Plane[]): boolean {\r\n        if (this.delayLoadState === Constants.DELAYLOADSTATE_LOADING) {\r\n            return false;\r\n        }\r\n\r\n        if (!super.isInFrustum(frustumPlanes)) {\r\n            return false;\r\n        }\r\n\r\n        this._checkDelayState();\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Sets the mesh material by the material or multiMaterial `id` property\r\n     * @param id is a string identifying the material or the multiMaterial\r\n     * @returns the current mesh\r\n     */\r\n    public setMaterialById(id: string): Mesh {\r\n        const materials = this.getScene().materials;\r\n        let index: number;\r\n        for (index = materials.length - 1; index > -1; index--) {\r\n            if (materials[index].id === id) {\r\n                this.material = materials[index];\r\n                return this;\r\n            }\r\n        }\r\n\r\n        // Multi\r\n        const multiMaterials = this.getScene().multiMaterials;\r\n        for (index = multiMaterials.length - 1; index > -1; index--) {\r\n            if (multiMaterials[index].id === id) {\r\n                this.material = multiMaterials[index];\r\n                return this;\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns as a new array populated with the mesh material and/or skeleton, if any.\r\n     * @returns an array of IAnimatable\r\n     */\r\n    public getAnimatables(): IAnimatable[] {\r\n        const results = new Array<IAnimatable>();\r\n\r\n        if (this.material) {\r\n            results.push(this.material);\r\n        }\r\n\r\n        if (this.skeleton) {\r\n            results.push(this.skeleton);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * Modifies the mesh geometry according to the passed transformation matrix.\r\n     * This method returns nothing but it really modifies the mesh even if it's originally not set as updatable.\r\n     * The mesh normals are modified using the same transformation.\r\n     * Note that, under the hood, this method sets a new VertexBuffer each call.\r\n     * @param transform defines the transform matrix to use\r\n     * @see https://doc.babylonjs.com/resources/baking_transformations\r\n     * @returns the current mesh\r\n     */\r\n    public bakeTransformIntoVertices(transform: Matrix): Mesh {\r\n        // Position\r\n        if (!this.isVerticesDataPresent(VertexBuffer.PositionKind)) {\r\n            return this;\r\n        }\r\n\r\n        const submeshes = this.subMeshes.splice(0);\r\n\r\n        this._resetPointsArrayCache();\r\n\r\n        let data = <FloatArray>this.getVerticesData(VertexBuffer.PositionKind);\r\n\r\n        let temp = new Array<number>();\r\n        let index: number;\r\n        for (index = 0; index < data.length; index += 3) {\r\n            Vector3.TransformCoordinates(Vector3.FromArray(data, index), transform).toArray(temp, index);\r\n        }\r\n\r\n        this.setVerticesData(VertexBuffer.PositionKind, temp, (<VertexBuffer>this.getVertexBuffer(VertexBuffer.PositionKind)).isUpdatable());\r\n\r\n        // Normals\r\n        if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {\r\n            data = <FloatArray>this.getVerticesData(VertexBuffer.NormalKind);\r\n            temp = [];\r\n            for (index = 0; index < data.length; index += 3) {\r\n                Vector3.TransformNormal(Vector3.FromArray(data, index), transform).normalize().toArray(temp, index);\r\n            }\r\n            this.setVerticesData(VertexBuffer.NormalKind, temp, (<VertexBuffer>this.getVertexBuffer(VertexBuffer.NormalKind)).isUpdatable());\r\n        }\r\n\r\n        // flip faces?\r\n        if (transform.determinant() < 0) {\r\n            this.flipFaces();\r\n        }\r\n\r\n        // Restore submeshes\r\n        this.releaseSubMeshes();\r\n        this.subMeshes = submeshes;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Modifies the mesh geometry according to its own current World Matrix.\r\n     * The mesh World Matrix is then reset.\r\n     * This method returns nothing but really modifies the mesh even if it's originally not set as updatable.\r\n     * Note that, under the hood, this method sets a new VertexBuffer each call.\r\n     * @see https://doc.babylonjs.com/resources/baking_transformations\r\n     * @param bakeIndependenlyOfChildren indicates whether to preserve all child nodes' World Matrix during baking\r\n     * @returns the current mesh\r\n     */\r\n    public bakeCurrentTransformIntoVertices(bakeIndependenlyOfChildren: boolean = true): Mesh {\r\n        this.bakeTransformIntoVertices(this.computeWorldMatrix(true));\r\n        this.resetLocalMatrix(bakeIndependenlyOfChildren);\r\n        return this;\r\n    }\r\n\r\n    // Cache\r\n\r\n    /** @hidden */\r\n    public get _positions(): Nullable<Vector3[]> {\r\n        if (this._internalAbstractMeshDataInfo._positions) {\r\n            return this._internalAbstractMeshDataInfo._positions;\r\n        }\r\n\r\n        if (this._geometry) {\r\n            return this._geometry._positions;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _resetPointsArrayCache(): Mesh {\r\n        if (this._geometry) {\r\n            this._geometry._resetPointsArrayCache();\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _generatePointsArray(): boolean {\r\n        if (this._geometry) {\r\n            return this._geometry._generatePointsArray();\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Mesh object generated from the current mesh properties.\r\n     * This method must not get confused with createInstance()\r\n     * @param name is a string, the name given to the new mesh\r\n     * @param newParent can be any Node object (default `null`)\r\n     * @param doNotCloneChildren allows/denies the recursive cloning of the original mesh children if any (default `false`)\r\n     * @param clonePhysicsImpostor allows/denies the cloning in the same time of the original mesh `body` used by the physics engine, if any (default `true`)\r\n     * @returns a new mesh\r\n     */\r\n    public clone(name: string = \"\", newParent: Nullable<Node> = null, doNotCloneChildren?: boolean, clonePhysicsImpostor: boolean = true): Mesh {\r\n        return new Mesh(name, this.getScene(), newParent, this, doNotCloneChildren, clonePhysicsImpostor);\r\n    }\r\n\r\n    /**\r\n     * Releases resources associated with this mesh.\r\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\r\n     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\r\n     */\r\n    public dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false): void {\r\n        this.morphTargetManager = null;\r\n\r\n        if (this._geometry) {\r\n            this._geometry.releaseForMesh(this, true);\r\n        }\r\n\r\n        const internalDataInfo = this._internalMeshDataInfo;\r\n\r\n        if (internalDataInfo._onBeforeDrawObservable) {\r\n            internalDataInfo._onBeforeDrawObservable.clear();\r\n        }\r\n\r\n        if (internalDataInfo._onBeforeBindObservable) {\r\n            internalDataInfo._onBeforeBindObservable.clear();\r\n        }\r\n\r\n        if (internalDataInfo._onBeforeRenderObservable) {\r\n            internalDataInfo._onBeforeRenderObservable.clear();\r\n        }\r\n\r\n        if (internalDataInfo._onAfterRenderObservable) {\r\n            internalDataInfo._onAfterRenderObservable.clear();\r\n        }\r\n\r\n        if (internalDataInfo._onBetweenPassObservable) {\r\n            internalDataInfo._onBetweenPassObservable.clear();\r\n        }\r\n\r\n        // Sources\r\n        if (this._scene.useClonedMeshMap) {\r\n            if (internalDataInfo.meshMap) {\r\n                for (const uniqueId in internalDataInfo.meshMap) {\r\n                    const mesh = internalDataInfo.meshMap[uniqueId];\r\n                    if (mesh) {\r\n                        mesh._internalMeshDataInfo._source = null;\r\n                        internalDataInfo.meshMap[uniqueId] = undefined;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (internalDataInfo._source && internalDataInfo._source._internalMeshDataInfo.meshMap) {\r\n                internalDataInfo._source._internalMeshDataInfo.meshMap[this.uniqueId] = undefined;\r\n            }\r\n        } else {\r\n            const meshes = this.getScene().meshes;\r\n            for (const abstractMesh of meshes) {\r\n                const mesh = abstractMesh as Mesh;\r\n                if (mesh._internalMeshDataInfo && mesh._internalMeshDataInfo._source && mesh._internalMeshDataInfo._source === this) {\r\n                    mesh._internalMeshDataInfo._source = null;\r\n                }\r\n            }\r\n        }\r\n\r\n        internalDataInfo._source = null;\r\n\r\n        // Instances\r\n        this._disposeInstanceSpecificData();\r\n\r\n        // Thin instances\r\n        this._disposeThinInstanceSpecificData();\r\n\r\n        if (this._internalMeshDataInfo._checkReadinessObserver) {\r\n            this._scene.onBeforeRenderObservable.remove(this._internalMeshDataInfo._checkReadinessObserver);\r\n        }\r\n\r\n        super.dispose(doNotRecurse, disposeMaterialAndTextures);\r\n    }\r\n\r\n    /** @hidden */\r\n    public _disposeInstanceSpecificData() {\r\n        // Do nothing\r\n    }\r\n\r\n    /** @hidden */\r\n    public _disposeThinInstanceSpecificData() {\r\n        // Do nothing\r\n    }\r\n\r\n    /** @hidden */\r\n    public _invalidateInstanceVertexArrayObject() {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Modifies the mesh geometry according to a displacement map.\r\n     * A displacement map is a colored image. Each pixel color value (actually a gradient computed from red, green, blue values) will give the displacement to apply to each mesh vertex.\r\n     * The mesh must be set as updatable. Its internal geometry is directly modified, no new buffer are allocated.\r\n     * @param url is a string, the URL from the image file is to be downloaded.\r\n     * @param minHeight is the lower limit of the displacement.\r\n     * @param maxHeight is the upper limit of the displacement.\r\n     * @param onSuccess is an optional Javascript function to be called just after the mesh is modified. It is passed the modified mesh and must return nothing.\r\n     * @param uvOffset is an optional vector2 used to offset UV.\r\n     * @param uvScale is an optional vector2 used to scale UV.\r\n     * @param forceUpdate defines whether or not to force an update of the generated buffers. This is useful to apply on a deserialized model for instance.\r\n     * @returns the Mesh.\r\n     */\r\n    public applyDisplacementMap(\r\n        url: string,\r\n        minHeight: number,\r\n        maxHeight: number,\r\n        onSuccess?: (mesh: Mesh) => void,\r\n        uvOffset?: Vector2,\r\n        uvScale?: Vector2,\r\n        forceUpdate = false\r\n    ): Mesh {\r\n        const scene = this.getScene();\r\n\r\n        const onload = (img: HTMLImageElement | ImageBitmap) => {\r\n            // Getting height map data\r\n            const heightMapWidth = img.width;\r\n            const heightMapHeight = img.height;\r\n            const canvas = this.getEngine().createCanvas(heightMapWidth, heightMapHeight);\r\n            const context = <CanvasRenderingContext2D>canvas.getContext(\"2d\");\r\n\r\n            context.drawImage(img, 0, 0);\r\n\r\n            // Create VertexData from map data\r\n            //Cast is due to wrong definition in lib.d.ts from ts 1.3 - https://github.com/Microsoft/TypeScript/issues/949\r\n            const buffer = <Uint8Array>(<any>context.getImageData(0, 0, heightMapWidth, heightMapHeight).data);\r\n\r\n            this.applyDisplacementMapFromBuffer(buffer, heightMapWidth, heightMapHeight, minHeight, maxHeight, uvOffset, uvScale, forceUpdate);\r\n            //execute success callback, if set\r\n            if (onSuccess) {\r\n                onSuccess(this);\r\n            }\r\n        };\r\n\r\n        Tools.LoadImage(url, onload, () => {}, scene.offlineProvider);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Modifies the mesh geometry according to a displacementMap buffer.\r\n     * A displacement map is a colored image. Each pixel color value (actually a gradient computed from red, green, blue values) will give the displacement to apply to each mesh vertex.\r\n     * The mesh must be set as updatable. Its internal geometry is directly modified, no new buffer are allocated.\r\n     * @param buffer is a `Uint8Array` buffer containing series of `Uint8` lower than 255, the red, green, blue and alpha values of each successive pixel.\r\n     * @param heightMapWidth is the width of the buffer image.\r\n     * @param heightMapHeight is the height of the buffer image.\r\n     * @param minHeight is the lower limit of the displacement.\r\n     * @param maxHeight is the upper limit of the displacement.\r\n     * @param uvOffset is an optional vector2 used to offset UV.\r\n     * @param uvScale is an optional vector2 used to scale UV.\r\n     * @param forceUpdate defines whether or not to force an update of the generated buffers. This is useful to apply on a deserialized model for instance.\r\n     * @returns the Mesh.\r\n     */\r\n    public applyDisplacementMapFromBuffer(\r\n        buffer: Uint8Array,\r\n        heightMapWidth: number,\r\n        heightMapHeight: number,\r\n        minHeight: number,\r\n        maxHeight: number,\r\n        uvOffset?: Vector2,\r\n        uvScale?: Vector2,\r\n        forceUpdate = false\r\n    ): Mesh {\r\n        if (!this.isVerticesDataPresent(VertexBuffer.PositionKind) || !this.isVerticesDataPresent(VertexBuffer.NormalKind) || !this.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n            Logger.Warn(\"Cannot call applyDisplacementMap: Given mesh is not complete. Position, Normal or UV are missing\");\r\n            return this;\r\n        }\r\n\r\n        const positions = <FloatArray>this.getVerticesData(VertexBuffer.PositionKind, true, true);\r\n        const normals = <FloatArray>this.getVerticesData(VertexBuffer.NormalKind);\r\n        const uvs = <number[]>this.getVerticesData(VertexBuffer.UVKind);\r\n        let position = Vector3.Zero();\r\n        const normal = Vector3.Zero();\r\n        const uv = Vector2.Zero();\r\n\r\n        uvOffset = uvOffset || Vector2.Zero();\r\n        uvScale = uvScale || new Vector2(1, 1);\r\n\r\n        for (let index = 0; index < positions.length; index += 3) {\r\n            Vector3.FromArrayToRef(positions, index, position);\r\n            Vector3.FromArrayToRef(normals, index, normal);\r\n            Vector2.FromArrayToRef(uvs, (index / 3) * 2, uv);\r\n\r\n            // Compute height\r\n            const u = (Math.abs(uv.x * uvScale.x + (uvOffset.x % 1)) * (heightMapWidth - 1)) % heightMapWidth | 0;\r\n            const v = (Math.abs(uv.y * uvScale.y + (uvOffset.y % 1)) * (heightMapHeight - 1)) % heightMapHeight | 0;\r\n\r\n            const pos = (u + v * heightMapWidth) * 4;\r\n            const r = buffer[pos] / 255.0;\r\n            const g = buffer[pos + 1] / 255.0;\r\n            const b = buffer[pos + 2] / 255.0;\r\n\r\n            const gradient = r * 0.3 + g * 0.59 + b * 0.11;\r\n\r\n            normal.normalize();\r\n            normal.scaleInPlace(minHeight + (maxHeight - minHeight) * gradient);\r\n            position = position.add(normal);\r\n\r\n            position.toArray(positions, index);\r\n        }\r\n\r\n        VertexData.ComputeNormals(positions, this.getIndices(), normals);\r\n\r\n        if (forceUpdate) {\r\n            this.setVerticesData(VertexBuffer.PositionKind, positions);\r\n            this.setVerticesData(VertexBuffer.NormalKind, normals);\r\n            this.setVerticesData(VertexBuffer.UVKind, uvs);\r\n        } else {\r\n            this.updateVerticesData(VertexBuffer.PositionKind, positions);\r\n            this.updateVerticesData(VertexBuffer.NormalKind, normals);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Modify the mesh to get a flat shading rendering.\r\n     * This means each mesh facet will then have its own normals. Usually new vertices are added in the mesh geometry to get this result.\r\n     * Warning : the mesh is really modified even if not set originally as updatable and, under the hood, a new VertexBuffer is allocated.\r\n     * @returns current mesh\r\n     */\r\n    public convertToFlatShadedMesh(): Mesh {\r\n        const kinds = this.getVerticesDataKinds();\r\n        const vbs: { [key: string]: VertexBuffer } = {};\r\n        const data: { [key: string]: FloatArray } = {};\r\n        const newdata: { [key: string]: Array<number> } = {};\r\n        let updatableNormals = false;\r\n        let kindIndex: number;\r\n        let kind: string;\r\n\r\n        for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\r\n            kind = kinds[kindIndex];\r\n            const vertexBuffer = <VertexBuffer>this.getVertexBuffer(kind);\r\n\r\n            // Check data consistency\r\n            const vertexData = vertexBuffer.getData();\r\n            if (vertexData instanceof Array || vertexData instanceof Float32Array) {\r\n                if (vertexData.length === 0) {\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            if (kind === VertexBuffer.NormalKind) {\r\n                updatableNormals = vertexBuffer.isUpdatable();\r\n                kinds.splice(kindIndex, 1);\r\n                kindIndex--;\r\n                continue;\r\n            }\r\n\r\n            vbs[kind] = vertexBuffer;\r\n            data[kind] = this.getVerticesData(kind)!;\r\n            newdata[kind] = [];\r\n        }\r\n\r\n        // Save previous submeshes\r\n        const previousSubmeshes = this.subMeshes.slice(0);\r\n\r\n        const indices = <IndicesArray>this.getIndices();\r\n        const totalIndices = this.getTotalIndices();\r\n\r\n        // Generating unique vertices per face\r\n        let index: number;\r\n        for (index = 0; index < totalIndices; index++) {\r\n            const vertexIndex = indices[index];\r\n\r\n            for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\r\n                kind = kinds[kindIndex];\r\n                if (!vbs[kind]) {\r\n                    continue;\r\n                }\r\n\r\n                const stride = vbs[kind].getStrideSize();\r\n\r\n                for (let offset = 0; offset < stride; offset++) {\r\n                    newdata[kind].push(data[kind][vertexIndex * stride + offset]);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Updating faces & normal\r\n        const normals = [];\r\n        const positions = newdata[VertexBuffer.PositionKind];\r\n        const useRightHandedSystem = this.getScene().useRightHandedSystem;\r\n        let flipNormalGeneration: boolean;\r\n        if (useRightHandedSystem) {\r\n            flipNormalGeneration = this.overrideMaterialSideOrientation === Constants.MATERIAL_CounterClockWiseSideOrientation;\r\n        } else {\r\n            flipNormalGeneration = this.overrideMaterialSideOrientation === Constants.MATERIAL_ClockWiseSideOrientation;\r\n        }\r\n\r\n        for (index = 0; index < totalIndices; index += 3) {\r\n            indices[index] = index;\r\n            indices[index + 1] = index + 1;\r\n            indices[index + 2] = index + 2;\r\n\r\n            const p1 = Vector3.FromArray(positions, index * 3);\r\n            const p2 = Vector3.FromArray(positions, (index + 1) * 3);\r\n            const p3 = Vector3.FromArray(positions, (index + 2) * 3);\r\n\r\n            const p1p2 = p1.subtract(p2);\r\n            const p3p2 = p3.subtract(p2);\r\n\r\n            const normal = Vector3.Normalize(Vector3.Cross(p1p2, p3p2));\r\n            if (flipNormalGeneration) {\r\n                normal.scaleInPlace(-1);\r\n            }\r\n\r\n            // Store same normals for every vertex\r\n            for (let localIndex = 0; localIndex < 3; localIndex++) {\r\n                normals.push(normal.x);\r\n                normals.push(normal.y);\r\n                normals.push(normal.z);\r\n            }\r\n        }\r\n\r\n        this.setIndices(indices);\r\n        this.setVerticesData(VertexBuffer.NormalKind, normals, updatableNormals);\r\n\r\n        // Updating vertex buffers\r\n        for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\r\n            kind = kinds[kindIndex];\r\n\r\n            if (!newdata[kind]) {\r\n                continue;\r\n            }\r\n\r\n            this.setVerticesData(kind, newdata[kind], vbs[kind].isUpdatable());\r\n        }\r\n\r\n        // Updating submeshes\r\n        this.releaseSubMeshes();\r\n        for (let submeshIndex = 0; submeshIndex < previousSubmeshes.length; submeshIndex++) {\r\n            const previousOne = previousSubmeshes[submeshIndex];\r\n            SubMesh.AddToMesh(previousOne.materialIndex, previousOne.indexStart, previousOne.indexCount, previousOne.indexStart, previousOne.indexCount, this);\r\n        }\r\n\r\n        this.synchronizeInstances();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * This method removes all the mesh indices and add new vertices (duplication) in order to unfold facets into buffers.\r\n     * In other words, more vertices, no more indices and a single bigger VBO.\r\n     * The mesh is really modified even if not set originally as updatable. Under the hood, a new VertexBuffer is allocated.\r\n     * @returns current mesh\r\n     */\r\n    public convertToUnIndexedMesh(): Mesh {\r\n        const kinds = this.getVerticesDataKinds();\r\n        const vbs: { [key: string]: VertexBuffer } = {};\r\n        const data: { [key: string]: FloatArray } = {};\r\n        const newdata: { [key: string]: Array<number> } = {};\r\n        let kindIndex: number;\r\n        let kind: string;\r\n        for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\r\n            kind = kinds[kindIndex];\r\n            const vertexBuffer = <VertexBuffer>this.getVertexBuffer(kind);\r\n            vbs[kind] = vertexBuffer;\r\n            data[kind] = <FloatArray>vbs[kind].getData();\r\n            newdata[kind] = [];\r\n        }\r\n\r\n        // Save previous submeshes\r\n        const previousSubmeshes = this.subMeshes.slice(0);\r\n\r\n        const indices = <IndicesArray>this.getIndices();\r\n        const totalIndices = this.getTotalIndices();\r\n\r\n        // Generating unique vertices per face\r\n        let index: number;\r\n        for (index = 0; index < totalIndices; index++) {\r\n            const vertexIndex = indices[index];\r\n\r\n            for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\r\n                kind = kinds[kindIndex];\r\n                const stride = vbs[kind].getStrideSize();\r\n\r\n                for (let offset = 0; offset < stride; offset++) {\r\n                    newdata[kind].push(data[kind][vertexIndex * stride + offset]);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Updating indices\r\n        for (index = 0; index < totalIndices; index += 3) {\r\n            indices[index] = index;\r\n            indices[index + 1] = index + 1;\r\n            indices[index + 2] = index + 2;\r\n        }\r\n\r\n        this.setIndices(indices);\r\n\r\n        // Updating vertex buffers\r\n        for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\r\n            kind = kinds[kindIndex];\r\n            this.setVerticesData(kind, newdata[kind], vbs[kind].isUpdatable());\r\n        }\r\n\r\n        // Updating submeshes\r\n        this.releaseSubMeshes();\r\n        for (let submeshIndex = 0; submeshIndex < previousSubmeshes.length; submeshIndex++) {\r\n            const previousOne = previousSubmeshes[submeshIndex];\r\n            SubMesh.AddToMesh(previousOne.materialIndex, previousOne.indexStart, previousOne.indexCount, previousOne.indexStart, previousOne.indexCount, this);\r\n        }\r\n\r\n        this._unIndexed = true;\r\n\r\n        this.synchronizeInstances();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Inverses facet orientations.\r\n     * Warning : the mesh is really modified even if not set originally as updatable. A new VertexBuffer is created under the hood each call.\r\n     * @param flipNormals will also inverts the normals\r\n     * @returns current mesh\r\n     */\r\n    public flipFaces(flipNormals: boolean = false): Mesh {\r\n        const vertex_data = VertexData.ExtractFromMesh(this);\r\n        let i: number;\r\n        if (flipNormals && this.isVerticesDataPresent(VertexBuffer.NormalKind) && vertex_data.normals) {\r\n            for (i = 0; i < vertex_data.normals.length; i++) {\r\n                vertex_data.normals[i] *= -1;\r\n            }\r\n        }\r\n\r\n        if (vertex_data.indices) {\r\n            let temp;\r\n            for (i = 0; i < vertex_data.indices.length; i += 3) {\r\n                // reassign indices\r\n                temp = vertex_data.indices[i + 1];\r\n                vertex_data.indices[i + 1] = vertex_data.indices[i + 2];\r\n                vertex_data.indices[i + 2] = temp;\r\n            }\r\n        }\r\n\r\n        vertex_data.applyToMesh(this, this.isVertexBufferUpdatable(VertexBuffer.PositionKind));\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Increase the number of facets and hence vertices in a mesh\r\n     * Vertex normals are interpolated from existing vertex normals\r\n     * Warning : the mesh is really modified even if not set originally as updatable. A new VertexBuffer is created under the hood each call.\r\n     * @param numberPerEdge the number of new vertices to add to each edge of a facet, optional default 1\r\n     */\r\n    public increaseVertices(numberPerEdge: number): void {\r\n        const vertex_data = VertexData.ExtractFromMesh(this);\r\n        const uvs = vertex_data.uvs && !Array.isArray(vertex_data.uvs) && Array.from ? Array.from(vertex_data.uvs) : vertex_data.uvs;\r\n        const currentIndices = vertex_data.indices && !Array.isArray(vertex_data.indices) && Array.from ? Array.from(vertex_data.indices) : vertex_data.indices;\r\n        const positions = vertex_data.positions && !Array.isArray(vertex_data.positions) && Array.from ? Array.from(vertex_data.positions) : vertex_data.positions;\r\n        const normals = vertex_data.normals && !Array.isArray(vertex_data.normals) && Array.from ? Array.from(vertex_data.normals) : vertex_data.normals;\r\n\r\n        if (!currentIndices || !positions || !normals || !uvs) {\r\n            Logger.Warn(\"VertexData contains null entries\");\r\n        } else {\r\n            vertex_data.indices = currentIndices;\r\n            vertex_data.positions = positions;\r\n            vertex_data.normals = normals;\r\n            vertex_data.uvs = uvs;\r\n\r\n            const segments: number = numberPerEdge + 1; //segments per current facet edge, become sides of new facets\r\n            const tempIndices: Array<Array<number>> = new Array();\r\n            for (let i = 0; i < segments + 1; i++) {\r\n                tempIndices[i] = new Array();\r\n            }\r\n            let a: number; //vertex index of one end of a side\r\n            let b: number; //vertex index of other end of the side\r\n            const deltaPosition: Vector3 = new Vector3(0, 0, 0);\r\n            const deltaNormal: Vector3 = new Vector3(0, 0, 0);\r\n            const deltaUV: Vector2 = new Vector2(0, 0);\r\n            const indices: number[] = new Array();\r\n            const vertexIndex: number[] = new Array();\r\n            const side: Array<Array<Array<number>>> = new Array();\r\n            let len: number;\r\n            let positionPtr: number = positions.length;\r\n            let uvPtr: number = uvs.length;\r\n\r\n            for (let i = 0; i < currentIndices.length; i += 3) {\r\n                vertexIndex[0] = currentIndices[i];\r\n                vertexIndex[1] = currentIndices[i + 1];\r\n                vertexIndex[2] = currentIndices[i + 2];\r\n                for (let j = 0; j < 3; j++) {\r\n                    a = vertexIndex[j];\r\n                    b = vertexIndex[(j + 1) % 3];\r\n                    if (side[a] === undefined && side[b] === undefined) {\r\n                        side[a] = new Array();\r\n                        side[b] = new Array();\r\n                    } else {\r\n                        if (side[a] === undefined) {\r\n                            side[a] = new Array();\r\n                        }\r\n                        if (side[b] === undefined) {\r\n                            side[b] = new Array();\r\n                        }\r\n                    }\r\n                    if (side[a][b] === undefined && side[b][a] === undefined) {\r\n                        side[a][b] = [];\r\n                        deltaPosition.x = (positions[3 * b] - positions[3 * a]) / segments;\r\n                        deltaPosition.y = (positions[3 * b + 1] - positions[3 * a + 1]) / segments;\r\n                        deltaPosition.z = (positions[3 * b + 2] - positions[3 * a + 2]) / segments;\r\n                        deltaNormal.x = (normals[3 * b] - normals[3 * a]) / segments;\r\n                        deltaNormal.y = (normals[3 * b + 1] - normals[3 * a + 1]) / segments;\r\n                        deltaNormal.z = (normals[3 * b + 2] - normals[3 * a + 2]) / segments;\r\n                        deltaUV.x = (uvs[2 * b] - uvs[2 * a]) / segments;\r\n                        deltaUV.y = (uvs[2 * b + 1] - uvs[2 * a + 1]) / segments;\r\n                        side[a][b].push(a);\r\n                        for (let k = 1; k < segments; k++) {\r\n                            side[a][b].push(positions.length / 3);\r\n                            positions[positionPtr] = positions[3 * a] + k * deltaPosition.x;\r\n                            normals[positionPtr++] = normals[3 * a] + k * deltaNormal.x;\r\n                            positions[positionPtr] = positions[3 * a + 1] + k * deltaPosition.y;\r\n                            normals[positionPtr++] = normals[3 * a + 1] + k * deltaNormal.y;\r\n                            positions[positionPtr] = positions[3 * a + 2] + k * deltaPosition.z;\r\n                            normals[positionPtr++] = normals[3 * a + 2] + k * deltaNormal.z;\r\n                            uvs[uvPtr++] = uvs[2 * a] + k * deltaUV.x;\r\n                            uvs[uvPtr++] = uvs[2 * a + 1] + k * deltaUV.y;\r\n                        }\r\n                        side[a][b].push(b);\r\n                        side[b][a] = new Array();\r\n                        len = side[a][b].length;\r\n                        for (let idx = 0; idx < len; idx++) {\r\n                            side[b][a][idx] = side[a][b][len - 1 - idx];\r\n                        }\r\n                    }\r\n                }\r\n                //Calculate positions, normals and uvs of new internal vertices\r\n                tempIndices[0][0] = currentIndices[i];\r\n                tempIndices[1][0] = side[currentIndices[i]][currentIndices[i + 1]][1];\r\n                tempIndices[1][1] = side[currentIndices[i]][currentIndices[i + 2]][1];\r\n                for (let k = 2; k < segments; k++) {\r\n                    tempIndices[k][0] = side[currentIndices[i]][currentIndices[i + 1]][k];\r\n                    tempIndices[k][k] = side[currentIndices[i]][currentIndices[i + 2]][k];\r\n                    deltaPosition.x = (positions[3 * tempIndices[k][k]] - positions[3 * tempIndices[k][0]]) / k;\r\n                    deltaPosition.y = (positions[3 * tempIndices[k][k] + 1] - positions[3 * tempIndices[k][0] + 1]) / k;\r\n                    deltaPosition.z = (positions[3 * tempIndices[k][k] + 2] - positions[3 * tempIndices[k][0] + 2]) / k;\r\n                    deltaNormal.x = (normals[3 * tempIndices[k][k]] - normals[3 * tempIndices[k][0]]) / k;\r\n                    deltaNormal.y = (normals[3 * tempIndices[k][k] + 1] - normals[3 * tempIndices[k][0] + 1]) / k;\r\n                    deltaNormal.z = (normals[3 * tempIndices[k][k] + 2] - normals[3 * tempIndices[k][0] + 2]) / k;\r\n                    deltaUV.x = (uvs[2 * tempIndices[k][k]] - uvs[2 * tempIndices[k][0]]) / k;\r\n                    deltaUV.y = (uvs[2 * tempIndices[k][k] + 1] - uvs[2 * tempIndices[k][0] + 1]) / k;\r\n                    for (let j = 1; j < k; j++) {\r\n                        tempIndices[k][j] = positions.length / 3;\r\n                        positions[positionPtr] = positions[3 * tempIndices[k][0]] + j * deltaPosition.x;\r\n                        normals[positionPtr++] = normals[3 * tempIndices[k][0]] + j * deltaNormal.x;\r\n                        positions[positionPtr] = positions[3 * tempIndices[k][0] + 1] + j * deltaPosition.y;\r\n                        normals[positionPtr++] = normals[3 * tempIndices[k][0] + 1] + j * deltaNormal.y;\r\n                        positions[positionPtr] = positions[3 * tempIndices[k][0] + 2] + j * deltaPosition.z;\r\n                        normals[positionPtr++] = normals[3 * tempIndices[k][0] + 2] + j * deltaNormal.z;\r\n                        uvs[uvPtr++] = uvs[2 * tempIndices[k][0]] + j * deltaUV.x;\r\n                        uvs[uvPtr++] = uvs[2 * tempIndices[k][0] + 1] + j * deltaUV.y;\r\n                    }\r\n                }\r\n                tempIndices[segments] = side[currentIndices[i + 1]][currentIndices[i + 2]];\r\n\r\n                // reform indices\r\n                indices.push(tempIndices[0][0], tempIndices[1][0], tempIndices[1][1]);\r\n                for (let k = 1; k < segments; k++) {\r\n                    let j: number;\r\n                    for (j = 0; j < k; j++) {\r\n                        indices.push(tempIndices[k][j], tempIndices[k + 1][j], tempIndices[k + 1][j + 1]);\r\n                        indices.push(tempIndices[k][j], tempIndices[k + 1][j + 1], tempIndices[k][j + 1]);\r\n                    }\r\n                    indices.push(tempIndices[k][j], tempIndices[k + 1][j], tempIndices[k + 1][j + 1]);\r\n                }\r\n            }\r\n\r\n            vertex_data.indices = indices;\r\n            vertex_data.applyToMesh(this, this.isVertexBufferUpdatable(VertexBuffer.PositionKind));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Force adjacent facets to share vertices and remove any facets that have all vertices in a line\r\n     * This will undo any application of covertToFlatShadedMesh\r\n     * Warning : the mesh is really modified even if not set originally as updatable. A new VertexBuffer is created under the hood each call.\r\n     */\r\n    public forceSharedVertices(): void {\r\n        const vertex_data = VertexData.ExtractFromMesh(this);\r\n        const currentUVs = vertex_data.uvs;\r\n        const currentIndices = vertex_data.indices;\r\n        const currentPositions = vertex_data.positions;\r\n        const currentColors = vertex_data.colors;\r\n\r\n        if (currentIndices === void 0 || currentPositions === void 0 || currentIndices === null || currentPositions === null) {\r\n            Logger.Warn(\"VertexData contains empty entries\");\r\n        } else {\r\n            const positions: Array<number> = new Array();\r\n            const indices: Array<number> = new Array();\r\n            const uvs: Array<number> = new Array();\r\n            const colors: Array<number> = new Array();\r\n            let pstring: Array<string> = new Array(); //lists facet vertex positions (a,b,c) as string \"a|b|c\"\r\n\r\n            let indexPtr: number = 0; // pointer to next available index value\r\n            const uniquePositions: { [key: string]: number } = {}; // unique vertex positions\r\n            let ptr: number; // pointer to element in uniquePositions\r\n            let facet: Array<number>;\r\n\r\n            for (let i = 0; i < currentIndices.length; i += 3) {\r\n                facet = [currentIndices[i], currentIndices[i + 1], currentIndices[i + 2]]; //facet vertex indices\r\n                pstring = new Array();\r\n                for (let j = 0; j < 3; j++) {\r\n                    pstring[j] = \"\";\r\n                    for (let k = 0; k < 3; k++) {\r\n                        //small values make 0\r\n                        if (Math.abs(currentPositions[3 * facet[j] + k]) < 0.00000001) {\r\n                            currentPositions[3 * facet[j] + k] = 0;\r\n                        }\r\n                        pstring[j] += currentPositions[3 * facet[j] + k] + \"|\";\r\n                    }\r\n                }\r\n                //check facet vertices to see that none are repeated\r\n                // do not process any facet that has a repeated vertex, ie is a line\r\n                if (!(pstring[0] == pstring[1] || pstring[0] == pstring[2] || pstring[1] == pstring[2])) {\r\n                    //for each facet position check if already listed in uniquePositions\r\n                    // if not listed add to uniquePositions and set index pointer\r\n                    // if listed use its index in uniquePositions and new index pointer\r\n                    for (let j = 0; j < 3; j++) {\r\n                        ptr = uniquePositions[pstring[j]];\r\n                        if (ptr === undefined) {\r\n                            uniquePositions[pstring[j]] = indexPtr;\r\n                            ptr = indexPtr++;\r\n                            //not listed so add individual x, y, z coordinates to positions\r\n                            for (let k = 0; k < 3; k++) {\r\n                                positions.push(currentPositions[3 * facet[j] + k]);\r\n                            }\r\n                            if (currentColors !== null && currentColors !== void 0) {\r\n                                for (let k = 0; k < 4; k++) {\r\n                                    colors.push(currentColors[4 * facet[j] + k]);\r\n                                }\r\n                            }\r\n                            if (currentUVs !== null && currentUVs !== void 0) {\r\n                                for (let k = 0; k < 2; k++) {\r\n                                    uvs.push(currentUVs[2 * facet[j] + k]);\r\n                                }\r\n                            }\r\n                        }\r\n                        // add new index pointer to indices array\r\n                        indices.push(ptr);\r\n                    }\r\n                }\r\n            }\r\n\r\n            const normals: Array<number> = new Array();\r\n            VertexData.ComputeNormals(positions, indices, normals);\r\n\r\n            //create new vertex data object and update\r\n            vertex_data.positions = positions;\r\n            vertex_data.indices = indices;\r\n            vertex_data.normals = normals;\r\n            if (currentUVs !== null && currentUVs !== void 0) {\r\n                vertex_data.uvs = uvs;\r\n            }\r\n            if (currentColors !== null && currentColors !== void 0) {\r\n                vertex_data.colors = colors;\r\n            }\r\n\r\n            vertex_data.applyToMesh(this, this.isVertexBufferUpdatable(VertexBuffer.PositionKind));\r\n        }\r\n    }\r\n\r\n    // Instances\r\n    /**\r\n     * @param name\r\n     * @param mesh\r\n     * @hidden\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/naming-convention\r\n    public static _instancedMeshFactory(name: string, mesh: Mesh): InstancedMesh {\r\n        throw _WarnImport(\"InstancedMesh\");\r\n    }\r\n\r\n    /**\r\n     * @param scene\r\n     * @param physicObject\r\n     * @param jsonObject\r\n     * @hidden\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public static _PhysicsImpostorParser(scene: Scene, physicObject: IPhysicsEnabledObject, jsonObject: any): PhysicsImpostor {\r\n        throw _WarnImport(\"PhysicsImpostor\");\r\n    }\r\n\r\n    /**\r\n     * Creates a new InstancedMesh object from the mesh model.\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_instances\r\n     * @param name defines the name of the new instance\r\n     * @returns a new InstancedMesh\r\n     */\r\n    public createInstance(name: string): InstancedMesh {\r\n        return Mesh._instancedMeshFactory(name, this);\r\n    }\r\n\r\n    /**\r\n     * Synchronises all the mesh instance submeshes to the current mesh submeshes, if any.\r\n     * After this call, all the mesh instances have the same submeshes than the current mesh.\r\n     * @returns the current mesh\r\n     */\r\n    public synchronizeInstances(): Mesh {\r\n        for (let instanceIndex = 0; instanceIndex < this.instances.length; instanceIndex++) {\r\n            const instance = this.instances[instanceIndex];\r\n            instance._syncSubMeshes();\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Optimization of the mesh's indices, in case a mesh has duplicated vertices.\r\n     * The function will only reorder the indices and will not remove unused vertices to avoid problems with submeshes.\r\n     * This should be used together with the simplification to avoid disappearing triangles.\r\n     * @param successCallback an optional success callback to be called after the optimization finished.\r\n     * @returns the current mesh\r\n     */\r\n    public optimizeIndices(successCallback?: (mesh?: Mesh) => void): Mesh {\r\n        const indices = <IndicesArray>this.getIndices();\r\n        const positions = this.getVerticesData(VertexBuffer.PositionKind);\r\n\r\n        if (!positions || !indices) {\r\n            return this;\r\n        }\r\n\r\n        const vectorPositions = new Array<Vector3>();\r\n        for (let pos = 0; pos < positions.length; pos = pos + 3) {\r\n            vectorPositions.push(Vector3.FromArray(positions, pos));\r\n        }\r\n        const dupes = new Array<number>();\r\n\r\n        AsyncLoop.SyncAsyncForLoop(\r\n            vectorPositions.length,\r\n            40,\r\n            (iteration) => {\r\n                const realPos = vectorPositions.length - 1 - iteration;\r\n                const testedPosition = vectorPositions[realPos];\r\n                for (let j = 0; j < realPos; ++j) {\r\n                    const againstPosition = vectorPositions[j];\r\n                    if (testedPosition.equals(againstPosition)) {\r\n                        dupes[realPos] = j;\r\n                        break;\r\n                    }\r\n                }\r\n            },\r\n            () => {\r\n                for (let i = 0; i < indices.length; ++i) {\r\n                    indices[i] = dupes[indices[i]] || indices[i];\r\n                }\r\n\r\n                //indices are now reordered\r\n                const originalSubMeshes = this.subMeshes.slice(0);\r\n                this.setIndices(indices);\r\n                this.subMeshes = originalSubMeshes;\r\n                if (successCallback) {\r\n                    successCallback(this);\r\n                }\r\n            }\r\n        );\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Serialize current mesh\r\n     * @param serializationObject defines the object which will receive the serialization data\r\n     */\r\n    public serialize(serializationObject: any): void {\r\n        serializationObject.name = this.name;\r\n        serializationObject.id = this.id;\r\n        serializationObject.uniqueId = this.uniqueId;\r\n        serializationObject.type = this.getClassName();\r\n\r\n        if (Tags && Tags.HasTags(this)) {\r\n            serializationObject.tags = Tags.GetTags(this);\r\n        }\r\n\r\n        serializationObject.position = this.position.asArray();\r\n\r\n        if (this.rotationQuaternion) {\r\n            serializationObject.rotationQuaternion = this.rotationQuaternion.asArray();\r\n        } else if (this.rotation) {\r\n            serializationObject.rotation = this.rotation.asArray();\r\n        }\r\n\r\n        serializationObject.scaling = this.scaling.asArray();\r\n        if (this._postMultiplyPivotMatrix) {\r\n            serializationObject.pivotMatrix = this.getPivotMatrix().asArray();\r\n        } else {\r\n            serializationObject.localMatrix = this.getPivotMatrix().asArray();\r\n        }\r\n\r\n        serializationObject.isEnabled = this.isEnabled(false);\r\n        serializationObject.isVisible = this.isVisible;\r\n        serializationObject.infiniteDistance = this.infiniteDistance;\r\n        serializationObject.pickable = this.isPickable;\r\n\r\n        serializationObject.receiveShadows = this.receiveShadows;\r\n\r\n        serializationObject.billboardMode = this.billboardMode;\r\n        serializationObject.visibility = this.visibility;\r\n\r\n        serializationObject.checkCollisions = this.checkCollisions;\r\n        serializationObject.isBlocker = this.isBlocker;\r\n        serializationObject.overrideMaterialSideOrientation = this.overrideMaterialSideOrientation;\r\n\r\n        // Parent\r\n        if (this.parent) {\r\n            serializationObject.parentId = this.parent.uniqueId;\r\n        }\r\n\r\n        // Geometry\r\n        serializationObject.isUnIndexed = this.isUnIndexed;\r\n        const geometry = this._geometry;\r\n        if (geometry && this.subMeshes) {\r\n            serializationObject.geometryUniqueId = geometry.uniqueId;\r\n            serializationObject.geometryId = geometry.id;\r\n\r\n            // SubMeshes\r\n            serializationObject.subMeshes = [];\r\n            for (let subIndex = 0; subIndex < this.subMeshes.length; subIndex++) {\r\n                const subMesh = this.subMeshes[subIndex];\r\n\r\n                serializationObject.subMeshes.push({\r\n                    materialIndex: subMesh.materialIndex,\r\n                    verticesStart: subMesh.verticesStart,\r\n                    verticesCount: subMesh.verticesCount,\r\n                    indexStart: subMesh.indexStart,\r\n                    indexCount: subMesh.indexCount,\r\n                });\r\n            }\r\n        }\r\n\r\n        // Material\r\n        if (this.material) {\r\n            if (!this.material.doNotSerialize) {\r\n                serializationObject.materialUniqueId = this.material.uniqueId;\r\n                serializationObject.materialId = this.material.id; // back compat\r\n            }\r\n        } else {\r\n            this.material = null;\r\n            serializationObject.materialUniqueId = this._scene.defaultMaterial.uniqueId;\r\n            serializationObject.materialId = this._scene.defaultMaterial.id; // back compat\r\n        }\r\n\r\n        // Morph targets\r\n        if (this.morphTargetManager) {\r\n            serializationObject.morphTargetManagerId = this.morphTargetManager.uniqueId;\r\n        }\r\n\r\n        // Skeleton\r\n        if (this.skeleton) {\r\n            serializationObject.skeletonId = this.skeleton.id;\r\n            serializationObject.numBoneInfluencers = this.numBoneInfluencers;\r\n        }\r\n\r\n        // Physics\r\n        //TODO implement correct serialization for physics impostors.\r\n        if (this.getScene()._getComponent(SceneComponentConstants.NAME_PHYSICSENGINE)) {\r\n            const impostor = this.getPhysicsImpostor();\r\n            if (impostor) {\r\n                serializationObject.physicsMass = impostor.getParam(\"mass\");\r\n                serializationObject.physicsFriction = impostor.getParam(\"friction\");\r\n                serializationObject.physicsRestitution = impostor.getParam(\"mass\");\r\n                serializationObject.physicsImpostor = impostor.type;\r\n            }\r\n        }\r\n\r\n        // Metadata\r\n        if (this.metadata) {\r\n            serializationObject.metadata = this.metadata;\r\n        }\r\n\r\n        // Instances\r\n        serializationObject.instances = [];\r\n        for (let index = 0; index < this.instances.length; index++) {\r\n            const instance = this.instances[index];\r\n            if (instance.doNotSerialize) {\r\n                continue;\r\n            }\r\n\r\n            const serializationInstance: any = {\r\n                name: instance.name,\r\n                id: instance.id,\r\n                isEnabled: instance.isEnabled(false),\r\n                isVisible: instance.isVisible,\r\n                isPickable: instance.isPickable,\r\n                checkCollisions: instance.checkCollisions,\r\n                position: instance.position.asArray(),\r\n                scaling: instance.scaling.asArray(),\r\n            };\r\n\r\n            if (instance.parent) {\r\n                serializationInstance.parentId = instance.parent.uniqueId;\r\n            }\r\n\r\n            if (instance.rotationQuaternion) {\r\n                serializationInstance.rotationQuaternion = instance.rotationQuaternion.asArray();\r\n            } else if (instance.rotation) {\r\n                serializationInstance.rotation = instance.rotation.asArray();\r\n            }\r\n\r\n            // Physics\r\n            //TODO implement correct serialization for physics impostors.\r\n            if (this.getScene()._getComponent(SceneComponentConstants.NAME_PHYSICSENGINE)) {\r\n                const impostor = instance.getPhysicsImpostor();\r\n                if (impostor) {\r\n                    serializationInstance.physicsMass = impostor.getParam(\"mass\");\r\n                    serializationInstance.physicsFriction = impostor.getParam(\"friction\");\r\n                    serializationInstance.physicsRestitution = impostor.getParam(\"mass\");\r\n                    serializationInstance.physicsImpostor = impostor.type;\r\n                }\r\n            }\r\n\r\n            // Metadata\r\n            if (instance.metadata) {\r\n                serializationInstance.metadata = instance.metadata;\r\n            }\r\n\r\n            serializationObject.instances.push(serializationInstance);\r\n\r\n            // Animations\r\n            SerializationHelper.AppendSerializedAnimations(instance, serializationInstance);\r\n            serializationInstance.ranges = instance.serializeAnimationRanges();\r\n        }\r\n\r\n        // Thin instances\r\n        if (this._thinInstanceDataStorage.instancesCount && this._thinInstanceDataStorage.matrixData) {\r\n            serializationObject.thinInstances = {\r\n                instancesCount: this._thinInstanceDataStorage.instancesCount,\r\n                matrixData: Tools.SliceToArray(this._thinInstanceDataStorage.matrixData),\r\n                matrixBufferSize: this._thinInstanceDataStorage.matrixBufferSize,\r\n                enablePicking: this.thinInstanceEnablePicking,\r\n            };\r\n\r\n            if (this._userThinInstanceBuffersStorage) {\r\n                const userThinInstance: any = {\r\n                    data: {},\r\n                    sizes: {},\r\n                    strides: {},\r\n                };\r\n\r\n                for (const kind in this._userThinInstanceBuffersStorage.data) {\r\n                    userThinInstance.data[kind] = Tools.SliceToArray(this._userThinInstanceBuffersStorage.data[kind]);\r\n                    userThinInstance.sizes[kind] = this._userThinInstanceBuffersStorage.sizes[kind];\r\n                    userThinInstance.strides[kind] = this._userThinInstanceBuffersStorage.strides[kind];\r\n                }\r\n\r\n                serializationObject.thinInstances.userThinInstance = userThinInstance;\r\n            }\r\n        }\r\n\r\n        // Animations\r\n        SerializationHelper.AppendSerializedAnimations(this, serializationObject);\r\n        serializationObject.ranges = this.serializeAnimationRanges();\r\n\r\n        // Layer mask\r\n        serializationObject.layerMask = this.layerMask;\r\n\r\n        // Alpha\r\n        serializationObject.alphaIndex = this.alphaIndex;\r\n        serializationObject.hasVertexAlpha = this.hasVertexAlpha;\r\n\r\n        // Overlay\r\n        serializationObject.overlayAlpha = this.overlayAlpha;\r\n        serializationObject.overlayColor = this.overlayColor.asArray();\r\n        serializationObject.renderOverlay = this.renderOverlay;\r\n\r\n        // Fog\r\n        serializationObject.applyFog = this.applyFog;\r\n\r\n        // Action Manager\r\n        if (this.actionManager) {\r\n            serializationObject.actions = this.actionManager.serialize(this.name);\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public _syncGeometryWithMorphTargetManager() {\r\n        if (!this.geometry) {\r\n            return;\r\n        }\r\n\r\n        this._markSubMeshesAsAttributesDirty();\r\n\r\n        const morphTargetManager = this._internalAbstractMeshDataInfo._morphTargetManager;\r\n        if (morphTargetManager && morphTargetManager.vertexCount) {\r\n            if (morphTargetManager.vertexCount !== this.getTotalVertices()) {\r\n                Logger.Error(\"Mesh is incompatible with morph targets. Targets and mesh must all have the same vertices count.\");\r\n                this.morphTargetManager = null;\r\n                return;\r\n            }\r\n\r\n            if (morphTargetManager.isUsingTextureForTargets) {\r\n                return;\r\n            }\r\n\r\n            for (let index = 0; index < morphTargetManager.numInfluencers; index++) {\r\n                const morphTarget = morphTargetManager.getActiveTarget(index);\r\n\r\n                const positions = morphTarget.getPositions();\r\n                if (!positions) {\r\n                    Logger.Error(\"Invalid morph target. Target must have positions.\");\r\n                    return;\r\n                }\r\n\r\n                this.geometry.setVerticesData(VertexBuffer.PositionKind + index, positions, false, 3);\r\n\r\n                const normals = morphTarget.getNormals();\r\n                if (normals) {\r\n                    this.geometry.setVerticesData(VertexBuffer.NormalKind + index, normals, false, 3);\r\n                }\r\n\r\n                const tangents = morphTarget.getTangents();\r\n                if (tangents) {\r\n                    this.geometry.setVerticesData(VertexBuffer.TangentKind + index, tangents, false, 3);\r\n                }\r\n\r\n                const uvs = morphTarget.getUVs();\r\n                if (uvs) {\r\n                    this.geometry.setVerticesData(VertexBuffer.UVKind + \"_\" + index, uvs, false, 2);\r\n                }\r\n            }\r\n        } else {\r\n            let index = 0;\r\n\r\n            // Positions\r\n            while (this.geometry.isVerticesDataPresent(VertexBuffer.PositionKind + index)) {\r\n                this.geometry.removeVerticesData(VertexBuffer.PositionKind + index);\r\n\r\n                if (this.geometry.isVerticesDataPresent(VertexBuffer.NormalKind + index)) {\r\n                    this.geometry.removeVerticesData(VertexBuffer.NormalKind + index);\r\n                }\r\n                if (this.geometry.isVerticesDataPresent(VertexBuffer.TangentKind + index)) {\r\n                    this.geometry.removeVerticesData(VertexBuffer.TangentKind + index);\r\n                }\r\n                if (this.geometry.isVerticesDataPresent(VertexBuffer.UVKind + index)) {\r\n                    this.geometry.removeVerticesData(VertexBuffer.UVKind + \"_\" + index);\r\n                }\r\n                index++;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * @param parsedMesh\r\n     * @param scene\r\n     * @hidden\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public static _GroundMeshParser = (parsedMesh: any, scene: Scene): Mesh => {\r\n        throw _WarnImport(\"GroundMesh\");\r\n    };\r\n\r\n    /**\r\n     * @param parsedMesh\r\n     * @param scene\r\n     * @hidden\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public static _GoldbergMeshParser = (parsedMesh: any, scene: Scene): GoldbergMesh => {\r\n        throw _WarnImport(\"GoldbergMesh\");\r\n    };\r\n\r\n    /**\r\n     * @param parsedMesh\r\n     * @param scene\r\n     * @hidden\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public static _LinesMeshParser = (parsedMesh: any, scene: Scene): Mesh => {\r\n        throw _WarnImport(\"LinesMesh\");\r\n    };\r\n\r\n    /**\r\n     * Returns a new Mesh object parsed from the source provided.\r\n     * @param parsedMesh is the source\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl is the root URL to prefix the `delayLoadingFile` property with\r\n     * @returns a new Mesh\r\n     */\r\n    public static Parse(parsedMesh: any, scene: Scene, rootUrl: string): Mesh {\r\n        let mesh: Mesh;\r\n\r\n        if (parsedMesh.type && parsedMesh.type === \"LinesMesh\") {\r\n            mesh = Mesh._LinesMeshParser(parsedMesh, scene);\r\n        } else if (parsedMesh.type && parsedMesh.type === \"GroundMesh\") {\r\n            mesh = Mesh._GroundMeshParser(parsedMesh, scene);\r\n        } else if (parsedMesh.type && parsedMesh.type === \"GoldbergMesh\") {\r\n            mesh = Mesh._GoldbergMeshParser(parsedMesh, scene);\r\n        } else {\r\n            mesh = new Mesh(parsedMesh.name, scene);\r\n        }\r\n        mesh.id = parsedMesh.id;\r\n\r\n        if (Tags) {\r\n            Tags.AddTagsTo(mesh, parsedMesh.tags);\r\n        }\r\n\r\n        mesh.position = Vector3.FromArray(parsedMesh.position);\r\n\r\n        if (parsedMesh.metadata !== undefined) {\r\n            mesh.metadata = parsedMesh.metadata;\r\n        }\r\n\r\n        if (parsedMesh.rotationQuaternion) {\r\n            mesh.rotationQuaternion = Quaternion.FromArray(parsedMesh.rotationQuaternion);\r\n        } else if (parsedMesh.rotation) {\r\n            mesh.rotation = Vector3.FromArray(parsedMesh.rotation);\r\n        }\r\n\r\n        mesh.scaling = Vector3.FromArray(parsedMesh.scaling);\r\n\r\n        if (parsedMesh.localMatrix) {\r\n            mesh.setPreTransformMatrix(Matrix.FromArray(parsedMesh.localMatrix));\r\n        } else if (parsedMesh.pivotMatrix) {\r\n            mesh.setPivotMatrix(Matrix.FromArray(parsedMesh.pivotMatrix));\r\n        }\r\n\r\n        mesh.setEnabled(parsedMesh.isEnabled);\r\n        mesh.isVisible = parsedMesh.isVisible;\r\n        mesh.infiniteDistance = parsedMesh.infiniteDistance;\r\n\r\n        mesh.showBoundingBox = parsedMesh.showBoundingBox;\r\n        mesh.showSubMeshesBoundingBox = parsedMesh.showSubMeshesBoundingBox;\r\n\r\n        if (parsedMesh.applyFog !== undefined) {\r\n            mesh.applyFog = parsedMesh.applyFog;\r\n        }\r\n\r\n        if (parsedMesh.pickable !== undefined) {\r\n            mesh.isPickable = parsedMesh.pickable;\r\n        }\r\n\r\n        if (parsedMesh.alphaIndex !== undefined) {\r\n            mesh.alphaIndex = parsedMesh.alphaIndex;\r\n        }\r\n\r\n        mesh.receiveShadows = parsedMesh.receiveShadows;\r\n\r\n        mesh.billboardMode = parsedMesh.billboardMode;\r\n\r\n        if (parsedMesh.visibility !== undefined) {\r\n            mesh.visibility = parsedMesh.visibility;\r\n        }\r\n\r\n        mesh.checkCollisions = parsedMesh.checkCollisions;\r\n        mesh.overrideMaterialSideOrientation = parsedMesh.overrideMaterialSideOrientation;\r\n\r\n        if (parsedMesh.isBlocker !== undefined) {\r\n            mesh.isBlocker = parsedMesh.isBlocker;\r\n        }\r\n\r\n        mesh._shouldGenerateFlatShading = parsedMesh.useFlatShading;\r\n\r\n        // freezeWorldMatrix\r\n        if (parsedMesh.freezeWorldMatrix) {\r\n            mesh._waitingData.freezeWorldMatrix = parsedMesh.freezeWorldMatrix;\r\n        }\r\n\r\n        // Parent\r\n        if (parsedMesh.parentId !== undefined) {\r\n            mesh._waitingParentId = parsedMesh.parentId;\r\n        }\r\n\r\n        // Actions\r\n        if (parsedMesh.actions !== undefined) {\r\n            mesh._waitingData.actions = parsedMesh.actions;\r\n        }\r\n\r\n        // Overlay\r\n        if (parsedMesh.overlayAlpha !== undefined) {\r\n            mesh.overlayAlpha = parsedMesh.overlayAlpha;\r\n        }\r\n\r\n        if (parsedMesh.overlayColor !== undefined) {\r\n            mesh.overlayColor = Color3.FromArray(parsedMesh.overlayColor);\r\n        }\r\n\r\n        if (parsedMesh.renderOverlay !== undefined) {\r\n            mesh.renderOverlay = parsedMesh.renderOverlay;\r\n        }\r\n\r\n        // Geometry\r\n        mesh.isUnIndexed = !!parsedMesh.isUnIndexed;\r\n        mesh.hasVertexAlpha = parsedMesh.hasVertexAlpha;\r\n\r\n        if (parsedMesh.delayLoadingFile) {\r\n            mesh.delayLoadState = Constants.DELAYLOADSTATE_NOTLOADED;\r\n            mesh.delayLoadingFile = rootUrl + parsedMesh.delayLoadingFile;\r\n            mesh.buildBoundingInfo(Vector3.FromArray(parsedMesh.boundingBoxMinimum), Vector3.FromArray(parsedMesh.boundingBoxMaximum));\r\n\r\n            if (parsedMesh._binaryInfo) {\r\n                mesh._binaryInfo = parsedMesh._binaryInfo;\r\n            }\r\n\r\n            mesh._delayInfo = [];\r\n            if (parsedMesh.hasUVs) {\r\n                mesh._delayInfo.push(VertexBuffer.UVKind);\r\n            }\r\n\r\n            if (parsedMesh.hasUVs2) {\r\n                mesh._delayInfo.push(VertexBuffer.UV2Kind);\r\n            }\r\n\r\n            if (parsedMesh.hasUVs3) {\r\n                mesh._delayInfo.push(VertexBuffer.UV3Kind);\r\n            }\r\n\r\n            if (parsedMesh.hasUVs4) {\r\n                mesh._delayInfo.push(VertexBuffer.UV4Kind);\r\n            }\r\n\r\n            if (parsedMesh.hasUVs5) {\r\n                mesh._delayInfo.push(VertexBuffer.UV5Kind);\r\n            }\r\n\r\n            if (parsedMesh.hasUVs6) {\r\n                mesh._delayInfo.push(VertexBuffer.UV6Kind);\r\n            }\r\n\r\n            if (parsedMesh.hasColors) {\r\n                mesh._delayInfo.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            if (parsedMesh.hasMatricesIndices) {\r\n                mesh._delayInfo.push(VertexBuffer.MatricesIndicesKind);\r\n            }\r\n\r\n            if (parsedMesh.hasMatricesWeights) {\r\n                mesh._delayInfo.push(VertexBuffer.MatricesWeightsKind);\r\n            }\r\n\r\n            mesh._delayLoadingFunction = Geometry._ImportGeometry;\r\n\r\n            if (SceneLoaderFlags.ForceFullSceneLoadingForIncremental) {\r\n                mesh._checkDelayState();\r\n            }\r\n        } else {\r\n            Geometry._ImportGeometry(parsedMesh, mesh);\r\n        }\r\n\r\n        // Material\r\n        if (parsedMesh.materialUniqueId) {\r\n            mesh._waitingMaterialId = parsedMesh.materialUniqueId;\r\n        } else if (parsedMesh.materialId) {\r\n            mesh._waitingMaterialId = parsedMesh.materialId;\r\n        }\r\n\r\n        // Morph targets\r\n        if (parsedMesh.morphTargetManagerId > -1) {\r\n            mesh.morphTargetManager = scene.getMorphTargetManagerById(parsedMesh.morphTargetManagerId);\r\n        }\r\n\r\n        // Skeleton\r\n        if (parsedMesh.skeletonId !== undefined && parsedMesh.skeletonId !== null) {\r\n            mesh.skeleton = scene.getLastSkeletonById(parsedMesh.skeletonId);\r\n            if (parsedMesh.numBoneInfluencers) {\r\n                mesh.numBoneInfluencers = parsedMesh.numBoneInfluencers;\r\n            }\r\n        }\r\n\r\n        // Animations\r\n        if (parsedMesh.animations) {\r\n            for (let animationIndex = 0; animationIndex < parsedMesh.animations.length; animationIndex++) {\r\n                const parsedAnimation = parsedMesh.animations[animationIndex];\r\n                const internalClass = GetClass(\"BABYLON.Animation\");\r\n                if (internalClass) {\r\n                    mesh.animations.push(internalClass.Parse(parsedAnimation));\r\n                }\r\n            }\r\n            Node.ParseAnimationRanges(mesh, parsedMesh, scene);\r\n        }\r\n\r\n        if (parsedMesh.autoAnimate) {\r\n            scene.beginAnimation(mesh, parsedMesh.autoAnimateFrom, parsedMesh.autoAnimateTo, parsedMesh.autoAnimateLoop, parsedMesh.autoAnimateSpeed || 1.0);\r\n        }\r\n\r\n        // Layer Mask\r\n        if (parsedMesh.layerMask && !isNaN(parsedMesh.layerMask)) {\r\n            mesh.layerMask = Math.abs(parseInt(parsedMesh.layerMask));\r\n        } else {\r\n            mesh.layerMask = 0x0fffffff;\r\n        }\r\n\r\n        // Physics\r\n        if (parsedMesh.physicsImpostor) {\r\n            Mesh._PhysicsImpostorParser(scene, mesh, parsedMesh);\r\n        }\r\n\r\n        // Levels\r\n        if (parsedMesh.lodMeshIds) {\r\n            mesh._waitingData.lods = {\r\n                ids: parsedMesh.lodMeshIds,\r\n                distances: parsedMesh.lodDistances ? parsedMesh.lodDistances : null,\r\n                coverages: parsedMesh.lodCoverages ? parsedMesh.lodCoverages : null,\r\n            };\r\n        }\r\n\r\n        // Instances\r\n        if (parsedMesh.instances) {\r\n            for (let index = 0; index < parsedMesh.instances.length; index++) {\r\n                const parsedInstance = parsedMesh.instances[index];\r\n                const instance = mesh.createInstance(parsedInstance.name);\r\n\r\n                if (parsedInstance.id) {\r\n                    instance.id = parsedInstance.id;\r\n                }\r\n\r\n                if (Tags) {\r\n                    if (parsedInstance.tags) {\r\n                        Tags.AddTagsTo(instance, parsedInstance.tags);\r\n                    } else {\r\n                        Tags.AddTagsTo(instance, parsedMesh.tags);\r\n                    }\r\n                }\r\n\r\n                instance.position = Vector3.FromArray(parsedInstance.position);\r\n\r\n                if (parsedInstance.metadata !== undefined) {\r\n                    instance.metadata = parsedInstance.metadata;\r\n                }\r\n\r\n                if (parsedInstance.parentId !== undefined) {\r\n                    instance._waitingParentId = parsedInstance.parentId;\r\n                }\r\n\r\n                if (parsedInstance.isEnabled !== undefined && parsedInstance.isEnabled !== null) {\r\n                    instance.setEnabled(parsedInstance.isEnabled);\r\n                }\r\n\r\n                if (parsedInstance.isVisible !== undefined && parsedInstance.isVisible !== null) {\r\n                    instance.isVisible = parsedInstance.isVisible;\r\n                }\r\n\r\n                if (parsedInstance.isPickable !== undefined && parsedInstance.isPickable !== null) {\r\n                    instance.isPickable = parsedInstance.isPickable;\r\n                }\r\n\r\n                if (parsedInstance.rotationQuaternion) {\r\n                    instance.rotationQuaternion = Quaternion.FromArray(parsedInstance.rotationQuaternion);\r\n                } else if (parsedInstance.rotation) {\r\n                    instance.rotation = Vector3.FromArray(parsedInstance.rotation);\r\n                }\r\n\r\n                instance.scaling = Vector3.FromArray(parsedInstance.scaling);\r\n\r\n                if (parsedInstance.checkCollisions != undefined && parsedInstance.checkCollisions != null) {\r\n                    instance.checkCollisions = parsedInstance.checkCollisions;\r\n                }\r\n                if (parsedInstance.pickable != undefined && parsedInstance.pickable != null) {\r\n                    instance.isPickable = parsedInstance.pickable;\r\n                }\r\n                if (parsedInstance.showBoundingBox != undefined && parsedInstance.showBoundingBox != null) {\r\n                    instance.showBoundingBox = parsedInstance.showBoundingBox;\r\n                }\r\n                if (parsedInstance.showSubMeshesBoundingBox != undefined && parsedInstance.showSubMeshesBoundingBox != null) {\r\n                    instance.showSubMeshesBoundingBox = parsedInstance.showSubMeshesBoundingBox;\r\n                }\r\n                if (parsedInstance.alphaIndex != undefined && parsedInstance.showSubMeshesBoundingBox != null) {\r\n                    instance.alphaIndex = parsedInstance.alphaIndex;\r\n                }\r\n\r\n                // Physics\r\n                if (parsedInstance.physicsImpostor) {\r\n                    Mesh._PhysicsImpostorParser(scene, instance, parsedInstance);\r\n                }\r\n\r\n                // Animation\r\n                if (parsedInstance.animations) {\r\n                    for (let animationIndex = 0; animationIndex < parsedInstance.animations.length; animationIndex++) {\r\n                        const parsedAnimation = parsedInstance.animations[animationIndex];\r\n                        const internalClass = GetClass(\"BABYLON.Animation\");\r\n                        if (internalClass) {\r\n                            instance.animations.push(internalClass.Parse(parsedAnimation));\r\n                        }\r\n                    }\r\n                    Node.ParseAnimationRanges(instance, parsedInstance, scene);\r\n\r\n                    if (parsedInstance.autoAnimate) {\r\n                        scene.beginAnimation(\r\n                            instance,\r\n                            parsedInstance.autoAnimateFrom,\r\n                            parsedInstance.autoAnimateTo,\r\n                            parsedInstance.autoAnimateLoop,\r\n                            parsedInstance.autoAnimateSpeed || 1.0\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Thin instances\r\n        if (parsedMesh.thinInstances) {\r\n            const thinInstances = parsedMesh.thinInstances;\r\n\r\n            mesh.thinInstanceEnablePicking = !!thinInstances.enablePicking;\r\n\r\n            if (thinInstances.matrixData) {\r\n                mesh.thinInstanceSetBuffer(\"matrix\", new Float32Array(thinInstances.matrixData), 16, false);\r\n\r\n                mesh._thinInstanceDataStorage.matrixBufferSize = thinInstances.matrixBufferSize;\r\n                mesh._thinInstanceDataStorage.instancesCount = thinInstances.instancesCount;\r\n            } else {\r\n                mesh._thinInstanceDataStorage.matrixBufferSize = thinInstances.matrixBufferSize;\r\n            }\r\n\r\n            if (parsedMesh.thinInstances.userThinInstance) {\r\n                const userThinInstance = parsedMesh.thinInstances.userThinInstance;\r\n\r\n                for (const kind in userThinInstance.data) {\r\n                    mesh.thinInstanceSetBuffer(kind, new Float32Array(userThinInstance.data[kind]), userThinInstance.strides[kind], false);\r\n                    mesh._userThinInstanceBuffersStorage.sizes[kind] = userThinInstance.sizes[kind];\r\n                }\r\n            }\r\n        }\r\n\r\n        return mesh;\r\n    }\r\n\r\n    // Skeletons\r\n\r\n    /**\r\n     * Prepare internal position array for software CPU skinning\r\n     * @returns original positions used for CPU skinning. Useful for integrating Morphing with skeletons in same mesh\r\n     */\r\n    public setPositionsForCPUSkinning(): Nullable<Float32Array> {\r\n        const internalDataInfo = this._internalMeshDataInfo;\r\n        if (!internalDataInfo._sourcePositions) {\r\n            const source = this.getVerticesData(VertexBuffer.PositionKind);\r\n            if (!source) {\r\n                return internalDataInfo._sourcePositions;\r\n            }\r\n\r\n            internalDataInfo._sourcePositions = new Float32Array(<any>source);\r\n\r\n            if (!this.isVertexBufferUpdatable(VertexBuffer.PositionKind)) {\r\n                this.setVerticesData(VertexBuffer.PositionKind, source, true);\r\n            }\r\n        }\r\n        return internalDataInfo._sourcePositions;\r\n    }\r\n\r\n    /**\r\n     * Prepare internal normal array for software CPU skinning\r\n     * @returns original normals used for CPU skinning. Useful for integrating Morphing with skeletons in same mesh.\r\n     */\r\n    public setNormalsForCPUSkinning(): Nullable<Float32Array> {\r\n        const internalDataInfo = this._internalMeshDataInfo;\r\n\r\n        if (!internalDataInfo._sourceNormals) {\r\n            const source = this.getVerticesData(VertexBuffer.NormalKind);\r\n\r\n            if (!source) {\r\n                return internalDataInfo._sourceNormals;\r\n            }\r\n\r\n            internalDataInfo._sourceNormals = new Float32Array(<any>source);\r\n\r\n            if (!this.isVertexBufferUpdatable(VertexBuffer.NormalKind)) {\r\n                this.setVerticesData(VertexBuffer.NormalKind, source, true);\r\n            }\r\n        }\r\n        return internalDataInfo._sourceNormals;\r\n    }\r\n\r\n    /**\r\n     * Updates the vertex buffer by applying transformation from the bones\r\n     * @param skeleton defines the skeleton to apply to current mesh\r\n     * @returns the current mesh\r\n     */\r\n    public applySkeleton(skeleton: Skeleton): Mesh {\r\n        if (!this.geometry) {\r\n            return this;\r\n        }\r\n\r\n        if (this.geometry._softwareSkinningFrameId == this.getScene().getFrameId()) {\r\n            return this;\r\n        }\r\n\r\n        this.geometry._softwareSkinningFrameId = this.getScene().getFrameId();\r\n\r\n        if (!this.isVerticesDataPresent(VertexBuffer.PositionKind)) {\r\n            return this;\r\n        }\r\n        if (!this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {\r\n            return this;\r\n        }\r\n        if (!this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {\r\n            return this;\r\n        }\r\n\r\n        const hasNormals = this.isVerticesDataPresent(VertexBuffer.NormalKind);\r\n\r\n        const internalDataInfo = this._internalMeshDataInfo;\r\n\r\n        if (!internalDataInfo._sourcePositions) {\r\n            const submeshes = this.subMeshes.slice();\r\n            this.setPositionsForCPUSkinning();\r\n            this.subMeshes = submeshes;\r\n        }\r\n\r\n        if (hasNormals && !internalDataInfo._sourceNormals) {\r\n            this.setNormalsForCPUSkinning();\r\n        }\r\n\r\n        // positionsData checks for not being Float32Array will only pass at most once\r\n        let positionsData = this.getVerticesData(VertexBuffer.PositionKind);\r\n\r\n        if (!positionsData) {\r\n            return this;\r\n        }\r\n\r\n        if (!(positionsData instanceof Float32Array)) {\r\n            positionsData = new Float32Array(positionsData);\r\n        }\r\n\r\n        // normalsData checks for not being Float32Array will only pass at most once\r\n        let normalsData = this.getVerticesData(VertexBuffer.NormalKind);\r\n\r\n        if (hasNormals) {\r\n            if (!normalsData) {\r\n                return this;\r\n            }\r\n\r\n            if (!(normalsData instanceof Float32Array)) {\r\n                normalsData = new Float32Array(normalsData);\r\n            }\r\n        }\r\n\r\n        const matricesIndicesData = this.getVerticesData(VertexBuffer.MatricesIndicesKind);\r\n        const matricesWeightsData = this.getVerticesData(VertexBuffer.MatricesWeightsKind);\r\n\r\n        if (!matricesWeightsData || !matricesIndicesData) {\r\n            return this;\r\n        }\r\n\r\n        const needExtras = this.numBoneInfluencers > 4;\r\n        const matricesIndicesExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesIndicesExtraKind) : null;\r\n        const matricesWeightsExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind) : null;\r\n\r\n        const skeletonMatrices = skeleton.getTransformMatrices(this);\r\n\r\n        const tempVector3 = Vector3.Zero();\r\n        const finalMatrix = new Matrix();\r\n        const tempMatrix = new Matrix();\r\n\r\n        let matWeightIdx = 0;\r\n        let inf: number;\r\n        for (let index = 0; index < positionsData.length; index += 3, matWeightIdx += 4) {\r\n            let weight: number;\r\n            for (inf = 0; inf < 4; inf++) {\r\n                weight = matricesWeightsData[matWeightIdx + inf];\r\n                if (weight > 0) {\r\n                    Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesData[matWeightIdx + inf] * 16), weight, tempMatrix);\r\n                    finalMatrix.addToSelf(tempMatrix);\r\n                }\r\n            }\r\n            if (needExtras) {\r\n                for (inf = 0; inf < 4; inf++) {\r\n                    weight = matricesWeightsExtraData![matWeightIdx + inf];\r\n                    if (weight > 0) {\r\n                        Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesExtraData![matWeightIdx + inf] * 16), weight, tempMatrix);\r\n                        finalMatrix.addToSelf(tempMatrix);\r\n                    }\r\n                }\r\n            }\r\n\r\n            Vector3.TransformCoordinatesFromFloatsToRef(\r\n                internalDataInfo._sourcePositions![index],\r\n                internalDataInfo._sourcePositions![index + 1],\r\n                internalDataInfo._sourcePositions![index + 2],\r\n                finalMatrix,\r\n                tempVector3\r\n            );\r\n            tempVector3.toArray(positionsData, index);\r\n\r\n            if (hasNormals) {\r\n                Vector3.TransformNormalFromFloatsToRef(\r\n                    internalDataInfo._sourceNormals![index],\r\n                    internalDataInfo._sourceNormals![index + 1],\r\n                    internalDataInfo._sourceNormals![index + 2],\r\n                    finalMatrix,\r\n                    tempVector3\r\n                );\r\n                tempVector3.toArray(normalsData!, index);\r\n            }\r\n\r\n            finalMatrix.reset();\r\n        }\r\n\r\n        this.updateVerticesData(VertexBuffer.PositionKind, positionsData);\r\n        if (hasNormals) {\r\n            this.updateVerticesData(VertexBuffer.NormalKind, normalsData!);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    // Tools\r\n\r\n    /**\r\n     * Returns an object containing a min and max Vector3 which are the minimum and maximum vectors of each mesh bounding box from the passed array, in the world coordinates\r\n     * @param meshes defines the list of meshes to scan\r\n     * @returns an object `{min:` Vector3`, max:` Vector3`}`\r\n     */\r\n    public static MinMax(meshes: AbstractMesh[]): { min: Vector3; max: Vector3 } {\r\n        let minVector: Nullable<Vector3> = null;\r\n        let maxVector: Nullable<Vector3> = null;\r\n\r\n        meshes.forEach(function (mesh) {\r\n            const boundingInfo = mesh.getBoundingInfo();\r\n\r\n            const boundingBox = boundingInfo.boundingBox;\r\n            if (!minVector || !maxVector) {\r\n                minVector = boundingBox.minimumWorld;\r\n                maxVector = boundingBox.maximumWorld;\r\n            } else {\r\n                minVector.minimizeInPlace(boundingBox.minimumWorld);\r\n                maxVector.maximizeInPlace(boundingBox.maximumWorld);\r\n            }\r\n        });\r\n\r\n        if (!minVector || !maxVector) {\r\n            return {\r\n                min: Vector3.Zero(),\r\n                max: Vector3.Zero(),\r\n            };\r\n        }\r\n\r\n        return {\r\n            min: minVector,\r\n            max: maxVector,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Returns the center of the `{min:` Vector3`, max:` Vector3`}` or the center of MinMax vector3 computed from a mesh array\r\n     * @param meshesOrMinMaxVector could be an array of meshes or a `{min:` Vector3`, max:` Vector3`}` object\r\n     * @returns a vector3\r\n     */\r\n    public static Center(meshesOrMinMaxVector: { min: Vector3; max: Vector3 } | AbstractMesh[]): Vector3 {\r\n        const minMaxVector = meshesOrMinMaxVector instanceof Array ? Mesh.MinMax(meshesOrMinMaxVector) : meshesOrMinMaxVector;\r\n        return Vector3.Center(minMaxVector.min, minMaxVector.max);\r\n    }\r\n\r\n    /**\r\n     * Merge the array of meshes into a single mesh for performance reasons.\r\n     * @param meshes defines he vertices source.  They should all be of the same material.  Entries can empty\r\n     * @param disposeSource when true (default), dispose of the vertices from the source meshes\r\n     * @param allow32BitsIndices when the sum of the vertices > 64k, this must be set to true\r\n     * @param meshSubclass when set, vertices inserted into this Mesh.  Meshes can then be merged into a Mesh sub-class.\r\n     * @param subdivideWithSubMeshes when true (false default), subdivide mesh to his subMesh array with meshes source.\r\n     * @param multiMultiMaterials when true (false default), subdivide mesh and accept multiple multi materials, ignores subdivideWithSubMeshes.\r\n     * @returns a new mesh\r\n     */\r\n    public static MergeMeshes(\r\n        meshes: Array<Mesh>,\r\n        disposeSource = true,\r\n        allow32BitsIndices?: boolean,\r\n        meshSubclass?: Mesh,\r\n        subdivideWithSubMeshes?: boolean,\r\n        multiMultiMaterials?: boolean\r\n    ) {\r\n        return runCoroutineSync(Mesh._MergeMeshesCoroutine(meshes, disposeSource, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials, false));\r\n    }\r\n\r\n    /**\r\n     * Merge the array of meshes into a single mesh for performance reasons.\r\n     * @param meshes defines he vertices source.  They should all be of the same material.  Entries can empty\r\n     * @param disposeSource when true (default), dispose of the vertices from the source meshes\r\n     * @param allow32BitsIndices when the sum of the vertices > 64k, this must be set to true\r\n     * @param meshSubclass when set, vertices inserted into this Mesh.  Meshes can then be merged into a Mesh sub-class.\r\n     * @param subdivideWithSubMeshes when true (false default), subdivide mesh to his subMesh array with meshes source.\r\n     * @param multiMultiMaterials when true (false default), subdivide mesh and accept multiple multi materials, ignores subdivideWithSubMeshes.\r\n     * @returns a new mesh\r\n     */\r\n    public static MergeMeshesAsync(\r\n        meshes: Array<Mesh>,\r\n        disposeSource = true,\r\n        allow32BitsIndices?: boolean,\r\n        meshSubclass?: Mesh,\r\n        subdivideWithSubMeshes?: boolean,\r\n        multiMultiMaterials?: boolean\r\n    ) {\r\n        return runCoroutineAsync(\r\n            Mesh._MergeMeshesCoroutine(meshes, disposeSource, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials, true),\r\n            createYieldingScheduler()\r\n        );\r\n    }\r\n\r\n    private static *_MergeMeshesCoroutine(\r\n        meshes: Array<Mesh>,\r\n        disposeSource = true,\r\n        allow32BitsIndices: boolean | undefined,\r\n        meshSubclass: Mesh | undefined,\r\n        subdivideWithSubMeshes: boolean | undefined,\r\n        multiMultiMaterials: boolean | undefined,\r\n        isAsync: boolean\r\n    ): Coroutine<Nullable<Mesh>> {\r\n        // Remove any null/undefined entries from the mesh array\r\n        meshes = meshes.filter(Boolean);\r\n\r\n        if (meshes.length === 0) {\r\n            return null;\r\n        }\r\n\r\n        let index: number;\r\n        if (!allow32BitsIndices) {\r\n            let totalVertices = 0;\r\n\r\n            // Counting vertices\r\n            for (index = 0; index < meshes.length; index++) {\r\n                totalVertices += meshes[index].getTotalVertices();\r\n\r\n                if (totalVertices >= 65536) {\r\n                    Logger.Warn(\"Cannot merge meshes because resulting mesh will have more than 65536 vertices. Please use allow32BitsIndices = true to use 32 bits indices\");\r\n                    return null;\r\n                }\r\n            }\r\n        }\r\n        if (multiMultiMaterials) {\r\n            subdivideWithSubMeshes = false;\r\n        }\r\n        const materialArray: Array<Material> = new Array<Material>();\r\n        const materialIndexArray: Array<number> = new Array<number>();\r\n        // Merge\r\n        const indiceArray: Array<number> = new Array<number>();\r\n        const currentOverrideMaterialSideOrientation = meshes[0].overrideMaterialSideOrientation;\r\n\r\n        for (index = 0; index < meshes.length; index++) {\r\n            const mesh = meshes[index];\r\n            if (mesh.isAnInstance) {\r\n                Logger.Warn(\"Cannot merge instance meshes.\");\r\n                return null;\r\n            }\r\n\r\n            if (currentOverrideMaterialSideOrientation !== mesh.overrideMaterialSideOrientation) {\r\n                Logger.Warn(\"Cannot merge meshes with different overrideMaterialSideOrientation values.\");\r\n                return null;\r\n            }\r\n\r\n            if (subdivideWithSubMeshes) {\r\n                indiceArray.push(mesh.getTotalIndices());\r\n            }\r\n\r\n            if (multiMultiMaterials) {\r\n                if (mesh.material) {\r\n                    const material = mesh.material;\r\n                    if (material instanceof MultiMaterial) {\r\n                        for (let matIndex = 0; matIndex < material.subMaterials.length; matIndex++) {\r\n                            if (materialArray.indexOf(<Material>material.subMaterials[matIndex]) < 0) {\r\n                                materialArray.push(<Material>material.subMaterials[matIndex]);\r\n                            }\r\n                        }\r\n                        for (let subIndex = 0; subIndex < mesh.subMeshes.length; subIndex++) {\r\n                            materialIndexArray.push(materialArray.indexOf(<Material>material.subMaterials[mesh.subMeshes[subIndex].materialIndex]));\r\n                            indiceArray.push(mesh.subMeshes[subIndex].indexCount);\r\n                        }\r\n                    } else {\r\n                        if (materialArray.indexOf(<Material>material) < 0) {\r\n                            materialArray.push(<Material>material);\r\n                        }\r\n                        for (let subIndex = 0; subIndex < mesh.subMeshes.length; subIndex++) {\r\n                            materialIndexArray.push(materialArray.indexOf(<Material>material));\r\n                            indiceArray.push(mesh.subMeshes[subIndex].indexCount);\r\n                        }\r\n                    }\r\n                } else {\r\n                    for (let subIndex = 0; subIndex < mesh.subMeshes.length; subIndex++) {\r\n                        materialIndexArray.push(0);\r\n                        indiceArray.push(mesh.subMeshes[subIndex].indexCount);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        const source = meshes[0];\r\n\r\n        const getVertexDataFromMesh = (mesh: Mesh) => {\r\n            const wm = mesh.computeWorldMatrix(true);\r\n            const vertexData = VertexData.ExtractFromMesh(mesh, false, false);\r\n            return [vertexData, wm] as const;\r\n        };\r\n\r\n        const [sourceVertexData, sourceTransform] = getVertexDataFromMesh(source);\r\n        if (isAsync) {\r\n            yield;\r\n        }\r\n\r\n        const meshVertexDatas = new Array<readonly [VertexData, Matrix]>(meshes.length - 1);\r\n        for (let i = 1; i < meshes.length; i++) {\r\n            meshVertexDatas[i - 1] = getVertexDataFromMesh(meshes[i]);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        const mergeCoroutine = sourceVertexData._mergeCoroutine(sourceTransform, meshVertexDatas, allow32BitsIndices, isAsync, !disposeSource);\r\n        let mergeCoroutineStep = mergeCoroutine.next();\r\n        while (!mergeCoroutineStep.done) {\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n            mergeCoroutineStep = mergeCoroutine.next();\r\n        }\r\n        const vertexData = mergeCoroutineStep.value;\r\n\r\n        if (!meshSubclass) {\r\n            meshSubclass = new Mesh(source.name + \"_merged\", source.getScene());\r\n        }\r\n\r\n        const applyToCoroutine = vertexData._applyToCoroutine(meshSubclass, undefined, isAsync);\r\n        let applyToCoroutineStep = applyToCoroutine.next();\r\n        while (!applyToCoroutineStep.done) {\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n            applyToCoroutineStep = applyToCoroutine.next();\r\n        }\r\n\r\n        // Setting properties\r\n        meshSubclass.checkCollisions = source.checkCollisions;\r\n        meshSubclass.overrideMaterialSideOrientation = source.overrideMaterialSideOrientation;\r\n\r\n        // Cleaning\r\n        if (disposeSource) {\r\n            for (index = 0; index < meshes.length; index++) {\r\n                meshes[index].dispose();\r\n            }\r\n        }\r\n\r\n        // Subdivide\r\n        if (subdivideWithSubMeshes || multiMultiMaterials) {\r\n            //-- removal of global submesh\r\n            meshSubclass.releaseSubMeshes();\r\n            index = 0;\r\n            let offset = 0;\r\n\r\n            //-- apply subdivision according to index table\r\n            while (index < indiceArray.length) {\r\n                SubMesh.CreateFromIndices(0, offset, indiceArray[index], meshSubclass, undefined, false);\r\n                offset += indiceArray[index];\r\n                index++;\r\n            }\r\n\r\n            for (const subMesh of meshSubclass.subMeshes) {\r\n                subMesh.refreshBoundingInfo();\r\n            }\r\n\r\n            meshSubclass.computeWorldMatrix(true);\r\n        }\r\n\r\n        if (multiMultiMaterials) {\r\n            const newMultiMaterial = new MultiMaterial(source.name + \"_merged\", source.getScene());\r\n            newMultiMaterial.subMaterials = materialArray;\r\n            for (let subIndex = 0; subIndex < meshSubclass.subMeshes.length; subIndex++) {\r\n                meshSubclass.subMeshes[subIndex].materialIndex = materialIndexArray[subIndex];\r\n            }\r\n            meshSubclass.material = newMultiMaterial;\r\n        } else {\r\n            meshSubclass.material = source.material;\r\n        }\r\n\r\n        return meshSubclass;\r\n    }\r\n\r\n    /**\r\n     * @param instance\r\n     * @hidden\r\n     */\r\n    public addInstance(instance: InstancedMesh) {\r\n        instance._indexInSourceMeshInstanceArray = this.instances.length;\r\n        this.instances.push(instance);\r\n    }\r\n\r\n    /**\r\n     * @param instance\r\n     * @hidden\r\n     */\r\n    public removeInstance(instance: InstancedMesh) {\r\n        // Remove from mesh\r\n        const index = instance._indexInSourceMeshInstanceArray;\r\n        if (index != -1) {\r\n            if (index !== this.instances.length - 1) {\r\n                const last = this.instances[this.instances.length - 1];\r\n                this.instances[index] = last;\r\n                last._indexInSourceMeshInstanceArray = index;\r\n            }\r\n\r\n            instance._indexInSourceMeshInstanceArray = -1;\r\n            this.instances.pop();\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public _shouldConvertRHS() {\r\n        return this.overrideMaterialSideOrientation === Material.CounterClockWiseSideOrientation;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.Mesh\", Mesh);\r\n"]}